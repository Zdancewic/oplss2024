<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Monads</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/rip.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 7: Reasoning about Interactive Programs</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Monads</h1>


<div class="doc">
<a id="lab135"></a><h2 class="section">Introduction to Monads</h2>

<div class="paragraph"> </div>

 One of the most common ways to combine computational behaviors is
<i>sequencing</i> them one after another.  As programmers, we are so familiar with
this notion of composition that it almost doesn't deserve a second thought.
However, as we will see below, it is very useful to <i>generalize</i> the idea of
sequential composition -- doing so will give us a framework for defining a wide
class of computational behaviors, all of which share the basic idea of "doing
something and then doing something afterwards".

<div class="paragraph"> </div>

This common abstraction is called a <span class="inlinecode"><span class="id" title="var">Monad</span></span>.  A <span class="inlinecode"><span class="id" title="var">Monad</span></span> is just a datatype that
can represent some kind of computational behavior that supports a well-behaved
notion of sequential composition. In this chapter, we will explore the basic
ideas behind the <span class="inlinecode"><span class="id" title="var">Monad</span></span> abstraction and see how they can be used to model
several kinds of computational behavior: imperative state, exceptions, and
nondeterminism.  
</div>

<div class="doc">
<a id="lab136"></a><h2 class="section">Modeling Imperative Programs</h2>

<div class="paragraph"> </div>

 As a warmup, let's start with the idea familiar from imperative programming.
Recall the Imp language semantics from <a href="Imp.html"><span class="inlineref">Imp</span></a>, which builds sequential
composition into the syntax of the programming language. In the command <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span>;<span class="id" title="var">c<sub>2</sub></span></span>,
the semicolon '<span class="inlinecode">;</span>' means to first do <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span></span> and then do <span class="inlinecode"><span class="id" title="var">c<sub>2</sub></span></span>.  It is given
meaning by the following rule of the operational semantics: 
<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="var">ceval</span> : <span class="id" title="var">com</span> → <span class="id" title="var">mem</span> → <span class="id" title="var">mem</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;| <span class="id" title="var">E_Seq</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c<sub>1</sub></span> <span class="id" title="var">c<sub>2</sub></span> <span class="id" title="var">st</span> <span class="id" title="var">st'</span> <span class="id" title="var">st''</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st</span>  =[ <span class="id" title="var">c<sub>1</sub></span> ]=&gt; <span class="id" title="var">st'</span>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st'</span> =[ <span class="id" title="var">c<sub>2</sub></span> ]=&gt; <span class="id" title="var">st''</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st</span>  =[ <span class="id" title="var">c<sub>1</sub></span> ; <span class="id" title="var">c<sub>2</sub></span> ]=&gt; <span class="id" title="var">st''</span>
</span> This rule says that, starting from memory <span class="inlinecode"><span class="id" title="var">st</span></span>, if <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span></span> runs to produce memory
<span class="inlinecode"><span class="id" title="var">st'</span></span> and we run <span class="inlinecode"><span class="id" title="var">c<sub>2</sub></span></span> starting in <span class="inlinecode"><span class="id" title="var">st'</span></span>, the result of the sequential
composition will be <span class="inlinecode"><span class="id" title="var">st''</span></span>.  This style of (large-step) operational semantics
defines the computational behavior of an Imp program as a "step" relation, which
is a Coq proposition about syntax.

<div class="paragraph"> </div>

Looking at the type of <span class="inlinecode"><span class="id" title="var">ceval</span></span> suggests that we could, instead of describing the
behavior of a command as a <i>relation</i> among a command and two memories, simply try
to model the semantics of an Imp program as a <i>function</i> from <span class="inlinecode"><span class="id" title="var">mem</span></span> to
<span class="inlinecode"><span class="id" title="var">mem</span></span>.  That is, we could replace <span class="inlinecode"><span class="id" title="var">ceval</span></span> with a function, called <span class="inlinecode"><span class="id" title="var">denote</span></span>,
that takes in the syntax of an Imp command and gives back a function on memories.
Then <span class="inlinecode"><span class="id" title="var">denote</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">mem</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">mem</span></span> and we can "run" the command <span class="inlinecode"><span class="id" title="var">c</span></span> starting from
an initial mem <span class="inlinecode"><span class="id" title="var">st</span></span> by doing <span class="inlinecode"><span class="id" title="var">denote</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">st</span></span>.  Note that, in contrast to the
relational operational semantics, the meaning of a command is defined in terms
of a Coq function.  Here, we use the term "denote" as an allusion to
"denotational semantics", a style of semantics that builds a mathematical model
of a programming language <i>compositionally</i> by induction on the syntax.

<div class="paragraph"> </div>

If we could make this approach work, then the meaning of sequential composition
can be defined as shown below:
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">denote</span> (<span class="id" title="var">c</span>:<span class="id" title="var">com</span>) : <span class="id" title="var">mem</span> → <span class="id" title="var">mem</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| ... <span class="comment">(*&nbsp;omitted&nbsp;*)</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c<sub>1</sub></span> ; <span class="id" title="var">c<sub>2</sub></span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">st</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">st'</span>  := <span class="id" title="var">denote</span> <span class="id" title="var">c<sub>1</sub></span> <span class="id" title="var">st</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">st''</span> := <span class="id" title="var">denote</span> <span class="id" title="var">c<sub>2</sub></span> <span class="id" title="var">st'</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st''</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
</span>  In the code above, we have used <span class="inlinecode"><span class="id" title="keyword">let</span></span> to name the intermediate results <span class="inlinecode"><span class="id" title="var">st'</span></span>
and <span class="inlinecode"><span class="id" title="var">st''</span></span> -- keep this in mind as we proceed, since one of the key ideas of
Monads is generalizing this <span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding operation.  However, it is also
enlightening to see that we could have written the case more succinctly as 
<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c<sub>1</sub></span> ; <span class="id" title="var">c<sub>2</sub></span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">st</span> ⇒ (<span class="id" title="var">denote</span> <span class="id" title="var">c<sub>2</sub></span> (<span class="id" title="var">denote</span> <span class="id" title="var">c<sub>1</sub></span> <span class="id" title="var">st</span>))
</span>Or, recalling that <span class="inlinecode">∘</span> stands for function composition, even as:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;| <span class="id" title="var">c<sub>1</sub></span> ; <span class="id" title="var">c<sub>2</sub></span> ⇒ (<span class="id" title="var">denote</span> <span class="id" title="var">c<sub>2</sub></span>) ∘ (<span class="id" title="var">denote</span> <span class="id" title="var">c<sub>1</sub></span>)
</span> There are a couple nice properties of this way of defining the semantics of
Imp.  First, like the large-step operational semantics, we see that the
sequential composition of Imp commands is given by induction on the structure of
the term, i.e., the meaning of <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span>;</span> <span class="inlinecode"><span class="id" title="var">c<sub>2</sub></span></span> is defined from the meaning of <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span></span> and
<span class="inlinecode"><span class="id" title="var">c<sub>2</sub></span></span> separately.  This enables easy proofs by induction on the structure of the
syntax.  (In contrast, small step semantics often don't have this property,
since, for example, the semantics for <span class="inlinecode"><span class="id" title="var">while</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="tactic">do</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> is not defined purely
in terms of the body <span class="inlinecode"><span class="id" title="var">c</span></span>.) Second, and unlike the large-step operational
semantics, since the command semantics are <i>functions</i>, they can be manipulated
as any other Coq function, including evaluating them using <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode">...</span>
or by extracting them to OCaml code.  That means that this style of semantics is
<i>executable</i>, a useful property for testing semantics or even implementing real
systems.  Finally, we will see throughout the rest of this Volume that this
style of semantics is easily extensible and can deal with many kinds of effects.
 Unfortunately, there is also a glaring problem for defining the full Imp
semantics this way: it doesn't work!  The problem is that an Imp program can
diverge, which means that, since Coq functions of type <span class="inlinecode"><span class="id" title="var">mem</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">mem</span></span> are
<i>total</i> (i.e., defined everywhere), it is not possible to use the type <span class="inlinecode"><span class="id" title="var">mem</span></span> <span class="inlinecode">→</span>
<span class="inlinecode"><span class="id" title="var">mem</span></span> to give a correct account of possibly looping programs; for some Imp
programs there is no final <span class="inlinecode"><span class="id" title="var">mem</span></span> that is produced.  The relational model
sidesteps the issue by exploiting <i>partiality</i> of the relation (it isn't defined
for all programs), but for large-step operational semantics, this comes at a the
cost of not (easily) being able to simultaneously model divergence and other
effects like I/O.  The denotational/monadic approach does have a good solution
to these issues, which we will see later in <a href="ITrees.html"><span class="inlineref">ITrees</span></a>.

<div class="paragraph"> </div>

For now, however, the idea of using Coq functions of type <span class="inlinecode"><span class="id" title="var">mem</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">mem</span></span> to
represent imperative programs that can modify memory is still appealing.
Moreover, thinking about how to generalize the situation above, which uses
<span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding in conjunction with function composition, will lead us to monads,
a general mechanism for representing many different kinds of effects, including
state, divergence, and I/O.  So let us continue to dive into modeling imperative
programs by functions that update mem.  
<div class="paragraph"> </div>

<a id="lab137"></a><h2 class="section">Simple States</h2>

</div>
<div class="code">
<span class="id" title="keyword">Module</span> <a id="SimpleStates" class="idref" href="#SimpleStates"><span class="id" title="module">SimpleStates</span></a>.<br/>
</div>

<div class="doc">
As a first step, let us move away from the "complex" states of Imp, which
are maps from (global) program variables to their values.  Instead, let us think
about how to model a single mutable cell that stores a natural number.  The
"state transformer" semantics of Imp is a function of type <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">state</span></span>, and
we can think of such a function as respresing an stateful computation.  With
just one cell, a computation that (possibly) updates the cell can be represented
simply as a function of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>.  For example, a computation that
increments the value of the cell is: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="SimpleStates.inc_cell" class="idref" href="#SimpleStates.inc_cell"><span class="id" title="definition">inc_cell</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="cell_value:1" class="idref" href="#cell_value:1"><span class="id" title="binder">cell_value</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) ⇒ 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cell_value:1"><span class="id" title="variable">cell_value</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Because this stateful computations are modeled as Coq functions, we can
"run" it by applying the function to the initial value for the
cell.  For instance, if cell initially holds the value <span class="inlinecode">2</span>, we have: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.inc_cell"><span class="id" title="definition">inc_cell</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">3</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

 Now suppose we want to model an imperative function that, in addition to
potentially mutating the cell contents, also takes in some extra input.  For
example, we can implement a function that increments the cell contents only if
an extra input of type <span class="inlinecode"><span class="id" title="var">bool</span></span> is <span class="inlinecode"><span class="id" title="var">true</span></span> as follows: 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="SimpleStates.inc_cell_cond" class="idref" href="#SimpleStates.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="b:2" class="idref" href="#b:2"><span class="id" title="binder">b</span></a> <a id="cell_value:3" class="idref" href="#cell_value:3"><span class="id" title="binder">cell_value</span></a> ⇒ <span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#b:2"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#SimpleStates.inc_cell"><span class="id" title="definition">inc_cell</span></a> <a class="idref" href="Monads.html#cell_value:3"><span class="id" title="variable">cell_value</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#cell_value:3"><span class="id" title="variable">cell_value</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">3</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">2</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

 (Aside) Note that the type <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> is isomorphic to <span class="inlinecode">(<span class="id" title="var">bool</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
which makes it clear that this computation takes an extra input.  We prefer the
former, "Curried", form because it will more smoothly generalize to other
situations later. Currying takes a function of type <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span></span> and turns it in
to a function of type <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span>. As an enlightening exercise, you might wish
to write, in Coq, a generic function of type <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span>,</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">→</span>
<span class="inlinecode"><span class="id" title="var">C</span>))</span> to see how that works. 
<div class="paragraph"> </div>

 Similarly, by adding an extra output, we can model a computation that
inspects the cell contents and returns <span class="inlinecode"><span class="id" title="var">true</span></span> if the stored value is less than
2: 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="SimpleStates.cell_lt_two" class="idref" href="#SimpleStates.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac<sub>4</sub>"><span class="id" title="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> '(<a id="cell_value:4" class="idref" href="#cell_value:4"><span class="id" title="binder"><span id="cell_value:5" class="id">cell_value</span></span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cell_value:4"><span class="id" title="variable">cell_value</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#cell_value:4"><span class="id" title="variable">cell_value</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#6b7621b45fff0af5e2b2cbb2bc2d4e1d"><span class="id" title="notation">&lt;?</span></a> 2<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> 1).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">false</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

 Note that <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> returns <span class="inlinecode"><span class="id" title="var">cell_value</span></span> <i>unchanged</i> as
part of its result.  This detail is crucial because it enable sequential
composition of "stateful" functions -- because <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> yields the
(unchanged) state, we can use that state in subsequent computations.  For
example, we can sequence a call to the <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span> after <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> like
this: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="SimpleStates.sequence_cell_example" class="idref" href="#SimpleStates.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="cell_value:6" class="idref" href="#cell_value:6"><span class="id" title="binder">cell_value</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">intermediate_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">b</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#SimpleStates.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> <a class="idref" href="Monads.html#cell_value:6"><span class="id" title="variable">cell_value</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="final_cell_value:7" class="idref" href="#final_cell_value:7"><span class="id" title="binder">final_cell_value</span></a> := <a class="idref" href="Monads.html#SimpleStates.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> <span class="id" title="var">b</span> <span class="id" title="var">intermediate_cell_value</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#final_cell_value:7"><span class="id" title="variable">final_cell_value</span></a>.<br/>
</div>

<div class="doc">
We can see here that the result of <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> includes the
<span class="inlinecode"><span class="id" title="var">intermediate_cell_value</span></span>, which is then fed in to <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span> to continue
the computation. Note also that <span class="inlinecode"><span class="id" title="var">b</span></span>, the boolean result from <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span>, is also
available for use in <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span>. As we will see, setting up this kind of
"plumbing" is common for defining <span class="inlinecode"><span class="id" title="var">Monads</span></span>.

<div class="paragraph"> </div>

Here, the resulting computation behaves as expected: if we run the example
starting with cells holding values less than 2, the cell is incremented, and
otherwise it is untouched.

</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">1</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> 1).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">2</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#SimpleStates.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">2</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#SimpleStates"><span class="id" title="module">SimpleStates</span></a>.<br/>
</div>

<div class="doc">
<a id="lab138"></a><h3 class="section">Making the types more uniform.</h3>

</div>
<div class="code">
<span class="id" title="keyword">Module</span> <a id="NatCell" class="idref" href="#NatCell"><span class="id" title="module">NatCell</span></a>.<br/>
</div>

<div class="doc">
In the examples above, <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span> and <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> had types of
different shapes: <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span> is an imperative computation with an extra <span class="inlinecode"><span class="id" title="var">bool</span></span>
<i>input</i>, and so has type <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> whereas <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> has an extra <span class="inlinecode"><span class="id" title="var">bool</span></span>
<i>output</i>, and so has type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>.  We can make the situation more uniform
by always taking into account the possibility of an extra input and output and,
at the same time, allowing the input and output to be types other than <span class="inlinecode"><span class="id" title="var">bool</span></span>.  If
a computation <i>doesn't</i> need the extra input or output, we can just use the
trivial <span class="inlinecode"><span class="id" title="var">unit</span></span> type, whose only value is <span class="inlinecode"><span class="id" title="var">tt</span></span>, instead.

<div class="paragraph"> </div>

These obeservations lead us to the following definition for a type of
"imperative functions" with access to a mutable <span class="inlinecode"><span class="id" title="var">nat</span></span> cell: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NatCell.nat_cell_fun" class="idref" href="#NatCell.nat_cell_fun"><span class="id" title="definition">nat_cell_fun</span></a> <a id="A:8" class="idref" href="#A:8"><span class="id" title="binder">A</span></a> <a id="B:9" class="idref" href="#B:9"><span class="id" title="binder">B</span></a> := <a class="idref" href="Monads.html#A:8"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac<sub>4</sub>"><span class="id" title="notation">×</span></a> <a class="idref" href="Monads.html#B:9"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">))</span></a>.<br/>
</div>

<div class="doc">
We can think of the type <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> as representing an imperative
function of type <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> that also has access to and can modify a mutable cell
of type <span class="inlinecode"><span class="id" title="var">nat</span></span>.  Note that the type <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> itself only mentions <span class="inlinecode"><span class="id" title="var">A</span></span> and
<span class="inlinecode"><span class="id" title="var">B</span></span>, which is why we can think of this as an "imperative function with input <span class="inlinecode"><span class="id" title="var">A</span></span>
and output <span class="inlinecode"><span class="id" title="var">B</span></span>".  
<div class="paragraph"> </div>

 With a bit of refactoring, we can re-implement <span class="inlinecode"><span class="id" title="var">inc_cell</span></span>, <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span>,
and <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> so that they fit this new type: 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">inc_cell_value</span></span> only modifies the state, so its input and output types are
both <span class="inlinecode"><span class="id" title="var">unit</span></span>: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="NatCell.inc_cell_value" class="idref" href="#NatCell.inc_cell_value"><span class="id" title="definition">inc_cell_value</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell_fun"><span class="id" title="definition">nat_cell_fun</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) (<a id="cell_value:10" class="idref" href="#cell_value:10"><span class="id" title="binder">cell_value</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="Monads.html#cell_value:10"><span class="id" title="variable">cell_value</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Note that <span class="inlinecode"><span class="id" title="var">inc_cell_value</span></span> still takes in the <span class="inlinecode"><span class="id" title="var">cell_value</span></span> as its second
argument -- the <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> type "hides" the presence of the <span class="inlinecode"><span class="id" title="var">nat</span></span> input and
output.  This detail is important because it means that, from the outside, the
type <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> will look more like a function of type <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.  Hiding the
details about how the state is implemented is a step towards generalizing to
other implementations of the same functionality.  For instance, we could have
defined a variant of <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> as <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">nat</span>))</span>, which swaps the
order of the result tuple.  That variant is equally expressive, but would
require slightly different code. 
<div class="paragraph"> </div>

 The function <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span> takes a <span class="inlinecode"><span class="id" title="var">bool</span></span> input and produces no output. To
fit it into our new form, we instantiate <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> so that the input type
is <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> and the output type <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, where <span class="inlinecode"><span class="id" title="var">unit</span></span> is the "trivial type"
and thus can stand for "no" output. Note that after refactoring
<span class="inlinecode"><span class="id" title="var">inc_cell_value</span></span>, we need to do a bit more work to use it in <span class="inlinecode"><span class="id" title="var">inc_cell_cond</span></span> --
we again use <span class="inlinecode"><span class="id" title="keyword">let</span></span> binding to explicitly "plumb" the current value of the state
through the computation.  
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="NatCell.inc_cell_cond" class="idref" href="#NatCell.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell_fun"><span class="id" title="definition">nat_cell_fun</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="b:11" class="idref" href="#b:11"><span class="id" title="binder">b</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) (<a id="cell_value:12" class="idref" href="#cell_value:12"><span class="id" title="binder">cell_value</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#b:11"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">intermediate_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#NatCell.inc_cell_value"><span class="id" title="definition">inc_cell_value</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="Monads.html#cell_value:12"><span class="id" title="variable">cell_value</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">intermediate_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cell_value:12"><span class="id" title="variable">cell_value</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> takes no input and leaves the cell state untouched, but
returns a <span class="inlinecode"><span class="id" title="var">bool</span></span> based on the value of the cell: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="NatCell.cell_lt_two" class="idref" href="#NatCell.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell_fun"><span class="id" title="definition">nat_cell_fun</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> (<a id="cell_value:13" class="idref" href="#cell_value:13"><span class="id" title="binder">cell_value</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cell_value:13"><span class="id" title="variable">cell_value</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#cell_value:13"><span class="id" title="variable">cell_value</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#6b7621b45fff0af5e2b2cbb2bc2d4e1d"><span class="id" title="notation">&lt;?</span></a> 2<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Finally, we can rewrite the <span class="inlinecode"><span class="id" title="var">sequence_cell_example</span></span> using the new types.
Note that its body has the same structure as the original; the only difference
is to account for the <span class="inlinecode"><span class="id" title="var">unit</span></span> types. 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="NatCell.sequence_cell_example" class="idref" href="#NatCell.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell_fun"><span class="id" title="definition">nat_cell_fun</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) <a id="cell_value:14" class="idref" href="#cell_value:14"><span class="id" title="binder">cell_value</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">intermediate_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">b</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#NatCell.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="Monads.html#cell_value:14"><span class="id" title="variable">cell_value</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">final_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#NatCell.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> <span class="id" title="var">b</span> <span class="id" title="var">intermediate_cell_value</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">final_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> 1).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example"><span class="id" title="definition">sequence_cell_example</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
<div class="paragraph"> </div>

 At this point, you might wonder what we have gained by introducing this
extra complexity to the types of these "imperative" functions.  The answer can
be seen in the structure common to the examples above, where we see that an
imperative function of type <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> is represented by <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span>.  By slightly shifting our perspective, we can say that such a
function takes an input of type <span class="inlinecode"><span class="id" title="var">A</span></span> and produces a <i>computation</i> as a result,
here represented as a function of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span>.  Moreover, the state of
the cell is "plumbed through" a sequential composition of such computations by
<span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding the intermediate states along with the intermediate values
produced by the earlier computations (such as the <span class="inlinecode"><span class="id" title="var">bool</span></span> produced by
<span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span>).  Finally, note that the computations above end by "returning"
the result of the imperative function paired with the current state of the cell
value.

<div class="paragraph"> </div>

The idea behind monads is to <i>abstract</i> over these two operations, which, among
other things, will allow us to hide the "plumbing" and write the
<span class="inlinecode"><span class="id" title="var">sequence_cell_value</span></span> example using notation that is much closer to standard
imperative code.

<div class="paragraph"> </div>

A monad is just a type that represents a compuation in such a way that it
supports at least these two operations: (1) a <span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding sequencing
operation, called <span class="inlinecode"><span class="id" title="var">bind</span></span>, and, (2) the ability to end a sequence by returning a
result, using an operation called <span class="inlinecode"><span class="id" title="var">ret</span></span>.  (These operations also have to behave
well together--i.e., they have to satisfy the "monad laws"--but we defer that
discussion until after we consider some more examples.)

<div class="paragraph"> </div>

For <span class="inlinecode"><span class="id" title="var">nat</span></span> cell computations, this leads us to define the following type, which is
describes just the "computation" part of the <span class="inlinecode"><span class="id" title="var">nat_cell_fun</span></span> definition: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="NatCell.nat_cell" class="idref" href="#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a id="B:15" class="idref" href="#B:15"><span class="id" title="binder">B</span></a> := <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac<sub>4</sub>"><span class="id" title="notation">×</span></a> <a class="idref" href="Monads.html#B:15"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
We can read <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> as "an imperative computation that can modify a cell
storing a <span class="inlinecode"><span class="id" title="var">nat</span></span> and that produces a result of type <span class="inlinecode"><span class="id" title="var">B</span></span>". This type is our first example
of a monad. 
<div class="paragraph"> </div>

<a id="lab139"></a><h3 class="section">Generalizing <span class="inlinecode"><span class="id" title="keyword">let</span></span></h3>

<div class="paragraph"> </div>

 First, let us see how to generalize <span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding.  Consider the use of
  <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> in the composition found in <span class="inlinecode"><span class="id" title="var">sequence_cell_example</span></span>:
<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">cell_value</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> (<span class="id" title="var">intermediate_cell_value</span>, <span class="id" title="var">b</span>) := <span class="id" title="var">cell_lt_two</span> <span class="id" title="var">tt</span> <span class="id" title="var">cell_value</span> <span class="id" title="keyword">in</span> ...<span class="id" title="var">body</span>...
</span>
<div class="paragraph"> </div>

 We see that when we run <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> starting from the initial <span class="inlinecode"><span class="id" title="var">cell_value</span></span>
it results in an <span class="inlinecode"><span class="id" title="var">intermediate_cell_value</span></span> along with a result <span class="inlinecode"><span class="id" title="var">b</span></span>.  The
<span class="inlinecode">...<span class="id" title="var">body</span>...</span> of the computation is also a <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> computation, and we have
<span class="inlinecode"><span class="id" title="var">intermediate_cell_value</span></span> in hand to pass as the starting value for the cell
when it runs, but it is also, in general, a function of <span class="inlinecode"><span class="id" title="var">b</span></span>.  Therefore, if we
abstract over <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span>, calling it <span class="inlinecode"><span class="id" title="var">m</span></span> (for "monadic computation") and
express <span class="inlinecode">...<span class="id" title="var">body</span>...</span> as a <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> computation that is a function of <span class="inlinecode"><span class="id" title="var">b</span></span>,
calling it <span class="inlinecode"><span class="id" title="var">k</span></span> (for "continuation") we arrive at this <span class="inlinecode"><span class="id" title="var">bind</span></span> operation for
<span class="inlinecode"><span class="id" title="var">nat_cell</span></span> is defined as: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="NatCell.nat_cell_bind" class="idref" href="#NatCell.nat_cell_bind"><span class="id" title="definition">nat_cell_bind</span></a> {<a id="A:16" class="idref" href="#A:16"><span class="id" title="binder">A</span></a> <a id="B:17" class="idref" href="#B:17"><span class="id" title="binder">B</span></a>} (<a id="m:18" class="idref" href="#m:18"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="Monads.html#A:16"><span class="id" title="variable">A</span></a>) (<a id="k:19" class="idref" href="#k:19"><span class="id" title="binder">k</span></a>:<a class="idref" href="Monads.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="Monads.html#B:17"><span class="id" title="variable">B</span></a>) : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="Monads.html#B:17"><span class="id" title="variable">B</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="cell_state:20" class="idref" href="#cell_state:20"><span class="id" title="binder">cell_state</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">new_cell_value</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">returned_a</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#m:18"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#cell_state:20"><span class="id" title="variable">cell_state</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#k:19"><span class="id" title="variable">k</span></a> <span class="id" title="var">returned_a</span> <span class="id" title="var">new_cell_value</span>.<br/>
</div>

<div class="doc">
Here, <span class="inlinecode"><span class="id" title="var">bind</span></span> takes a <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> computation <span class="inlinecode"><span class="id" title="var">m</span></span> that computes an
intermediate result of type <span class="inlinecode"><span class="id" title="var">A</span></span>, along with a continuation, which is just a
function from <span class="inlinecode"><span class="id" title="var">A</span></span> to a <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> computation of type <span class="inlinecode"><span class="id" title="var">B</span></span>, and composes them
sequentially.

<div class="paragraph"> </div>

 The correspondence with <span class="inlinecode"><span class="id" title="keyword">let</span></span> binding can be made more apparent by
introducing some notation (which is relatively standard for monads).  The code
<span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">&lt;-</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">;;</span> <span class="inlinecode"><span class="id" title="var">body</span></span> can be read as "bind the result of running computation <span class="inlinecode"><span class="id" title="var">m</span></span> as
<span class="inlinecode"><span class="id" title="var">x</span></span> in the <span class="inlinecode"><span class="id" title="var">body</span></span> of the computation."  
</div>
<div class="code">
#[<span class="id" title="var">local</span>]<br/>
<span class="id" title="keyword">Notation</span> "x &lt;- m ;; body" := (<a class="idref" href="Monads.html#NatCell.nat_cell_bind"><span class="id" title="definition">nat_cell_bind</span></a> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <a id="x:21" class="idref" href="#x:21"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">body</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 61, <span class="id" title="var">m</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
</div>

<div class="doc">
This notation lets us illustrate the parallels between the standard Coq <span class="inlinecode"><span class="id" title="keyword">let</span></span>-form (left),
the version for <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> that makes the state plumbing explicit (center), and
the monadic version, which again hides the state plumbing (right):
 
<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------- <span class="id" title="var">Equal</span> <span class="id" title="tactic">by</span> <span class="id" title="var">Unfolding</span> <span class="id" title="var">Definitions</span> --------------+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|                                                               |<br/>
<span class="id" title="var">STANDARD</span> <span class="id" title="var">COQ</span>:    <span class="id" title="var">EXPLICIT</span> <span class="id" title="var">STATE</span> <span class="id" title="var">PLUMBING</span>:   <span class="id" title="var">BIND</span>:                <span class="id" title="var">MONADIC</span> <span class="id" title="var">NOTATION</span>:<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="var">m</span> <span class="id" title="keyword">in</span>    <span class="id" title="keyword">let</span> (σ', <span class="id" title="var">x</span>) := <span class="id" title="var">m</span> σ <span class="id" title="keyword">in</span>      <span class="id" title="var">bind</span> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒     <span class="id" title="var">x</span> &lt;- <span class="id" title="var">m</span> ;;<br/>
&nbsp;&nbsp;<span class="id" title="var">rest</span> <span class="id" title="var">x</span>           <span class="id" title="var">rest</span> <span class="id" title="var">x</span> σ'                  <span class="id" title="var">rest</span> <span class="id" title="var">x</span>)             <span class="id" title="var">rest</span> <span class="id" title="var">x</span>
</span> 
<div class="paragraph"> </div>

 Already we can rewrite the <span class="inlinecode"><span class="id" title="var">sequence_cell_example</span></span> much more cleanly as follows,
where the input type <span class="inlinecode"><span class="id" title="var">unit</span></span> means that it takes no (interesting) input and the
output type <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> <span class="inlinecode"><span class="id" title="var">unit</span></span> indicates that it produces no interesting output, but
may update the <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> state:

</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="NatCell.sequence_cell_example2" class="idref" href="#NatCell.sequence_cell_example2"><span class="id" title="definition">sequence_cell_example2</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="b:22" class="idref" href="#b:22"><span class="id" title="binder">b</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.cell_lt_two"><span class="id" title="definition">cell_lt_two</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#NatCell.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> <a class="idref" href="Monads.html#b:22"><span class="id" title="variable">b</span></a>.<br/>
</div>

<div class="doc">
To see that this presentation does indeed "thread" the <span class="inlinecode"><span class="id" title="var">cell_state</span></span> through,
the computation, we can unfold the definitions to see how it it is used "under the hood":

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="NatCell.sequence_cell_example2_unfolded" class="idref" href="#NatCell.sequence_cell_example2_unfolded"><span class="id" title="lemma">sequence_cell_example2_unfolded</span></a>: <a class="idref" href="Monads.html#NatCell.sequence_cell_example2"><span class="id" title="definition">sequence_cell_example2</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) (<a id="cell_state:23" class="idref" href="#cell_state:23"><span class="id" title="binder">cell_state</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) ⇒ <a class="idref" href="Monads.html#NatCell.inc_cell_cond"><span class="id" title="definition">inc_cell_cond</span></a> (<a class="idref" href="Monads.html#cell_state:23"><span class="id" title="variable">cell_state</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#6b7621b45fff0af5e2b2cbb2bc2d4e1d"><span class="id" title="notation">&lt;?</span></a> 2) <a class="idref" href="Monads.html#cell_state:23"><span class="id" title="variable">cell_state</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#NatCell.sequence_cell_example2"><span class="id" title="definition">sequence_cell_example2</span></a>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#NatCell.nat_cell_bind"><span class="id" title="definition">nat_cell_bind</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
As before, we can run such a computation, but, in addition to the <span class="inlinecode"><span class="id" title="var">tt</span></span>
input, we must also supply the initial state of the nat cell.  Note that we
get out the <span class="inlinecode"><span class="id" title="var">unit</span></span> result as well: 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example2"><span class="id" title="definition">sequence_cell_example2</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example2"><span class="id" title="definition">sequence_cell_example2</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> 1).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example2"><span class="id" title="definition">sequence_cell_example2</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
<div class="paragraph"> </div>

<a id="lab140"></a><h3 class="section">Generalizing return</h3>

<div class="paragraph"> </div>

 Abstracting over the ability to "return" a value from a computation is
(usually) more straightforward than abstracting over <span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding. For
<span class="inlinecode"><span class="id" title="var">nat_cell</span></span> computations, this amounts to just pairing the result with the
current cell state, so we have: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="NatCell.nat_cell_ret" class="idref" href="#NatCell.nat_cell_ret"><span class="id" title="definition">nat_cell_ret</span></a> {<a id="A:24" class="idref" href="#A:24"><span class="id" title="binder">A</span></a>} : <a class="idref" href="Monads.html#A:24"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="Monads.html#A:24"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="result:25" class="idref" href="#result:25"><span class="id" title="binder">result</span></a>:<a class="idref" href="Monads.html#A:24"><span class="id" title="variable">A</span></a>) (<a id="cell_state:26" class="idref" href="#cell_state:26"><span class="id" title="binder">cell_state</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cell_state:26"><span class="id" title="variable">cell_state</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#result:25"><span class="id" title="variable">result</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
We introduce the (standard) monadic notation, <span class="inlinecode"><span class="id" title="var">ret</span></span>, as a useful
abbreviation.
</div>
<div class="code">

#[<span class="id" title="var">local</span>]<br/>
&nbsp;<span class="id" title="keyword">Notation</span> "'ret' a" := (<a class="idref" href="Monads.html#NatCell.nat_cell_ret"><span class="id" title="definition">nat_cell_ret</span></a> <span class="id" title="var">a</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50).<br/>
</div>

<div class="doc">
For example, to define a function takes in a <span class="inlinecode"><span class="id" title="var">b</span>:<span class="id" title="var">bool</span></span> and returns a "pure"
computation that negates <span class="inlinecode"><span class="id" title="var">b</span></span>, we write: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="NatCell.neg_nat_cell" class="idref" href="#NatCell.neg_nat_cell"><span class="id" title="definition">neg_nat_cell</span></a> (<a id="b:27" class="idref" href="#b:27"><span class="id" title="binder">b</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Monads.html#b:27"><span class="id" title="variable">b</span></a><a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Although <span class="inlinecode"><span class="id" title="var">ret</span></span> is "pure" (the cell value doesn't change and isn't accessed),
we still need to supply the initial state of the nat cell when we run the
computation: 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.neg_nat_cell"><span class="id" title="definition">neg_nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> 3).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(3,</span> <span class="inlinecode"><span class="id" title="var">false</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.neg_nat_cell"><span class="id" title="definition">neg_nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> 17).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(17,</span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

<a id="lab141"></a><h3 class="section">Recap</h3>

</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">nat_cell</span></span> is the first example of a monad that we have seen so far.  To
recap, the key ideas are: (1) a monad is a type that represents "computations"
returning some value. (2) a monad has a natural notion of "sequential"
composition, given by <span class="inlinecode"><span class="id" title="var">bind</span></span>, that says what it means to perform one computation
after computing another; the behavior of the second computation can depend on
the result of the first. (3) a monad has a natural noation of what it means to
"return" a value, given by <span class="inlinecode"><span class="id" title="var">ret</span></span>.

<div class="paragraph"> </div>

We will define more precisely below what it means for these operations to be
"natural", after we have seen some other examples of monads in action.  But
before doing that, let us explore what we can do with <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> a bit further.

<div class="paragraph"> </div>

<a id="lab142"></a><h2 class="section">More state operations</h2>

<div class="paragraph"> </div>

 We have already seen that we can, by hand, write Coq functions like
<span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span>, which are <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> compuations that do (somewhat) interesting
manipulations of the state to produce a result.  However to do that by hand, we
had to know about the details of how the <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> monad is implemented, i.e.,
that it is defined as a type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> (and not, for instance, as the
isomorphic type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>). It would be cleaner if we could program such
computations without having to work with the monad definition explicitly.

<div class="paragraph"> </div>

Fortunately, most monads support notions of "effects", which are simply
"primitive" computations of monad type.  These effects can be implemented
concretely once-and-for-all, by exploiting the details of the type defining the
monad, but then they can be re-used in many applications without resorting to
looking "under the covers" of the monad abstraction.

<div class="paragraph"> </div>

For <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> the two effects are <span class="inlinecode"><span class="id" title="var">get</span></span>, which simply returns the current state
of the cell and <span class="inlinecode"><span class="id" title="var">put</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which updates the state to be <span class="inlinecode"><span class="id" title="var">n</span></span> and returns only the
<span class="inlinecode"><span class="id" title="var">unit</span></span> value. These are simple enough to implement: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NatCell.get" class="idref" href="#NatCell.get"><span class="id" title="definition">get</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="cell_state:28" class="idref" href="#cell_state:28"><span class="id" title="binder">cell_state</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cell_state:28"><span class="id" title="variable">cell_state</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#cell_state:28"><span class="id" title="variable">cell_state</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="NatCell.put" class="idref" href="#NatCell.put"><span class="id" title="definition">put</span></a> (<a id="n:29" class="idref" href="#n:29"><span class="id" title="binder">n</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="cell_state:30" class="idref" href="#cell_state:30"><span class="id" title="binder">cell_state</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#n:29"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
With those two primitive operations in hand, we can now revisit the
examples from before.  Now, however, we can use a mixture of <span class="inlinecode"><span class="id" title="var">nat_cell</span></span>
computations and functions that that return <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> computations to achieve a
much cleaner organization of the code.  Our new notations for <span class="inlinecode"><span class="id" title="var">bind</span></span> and <span class="inlinecode"><span class="id" title="var">ret</span></span>
also help.

<div class="paragraph"> </div>

 A computation that increments the current cell value: (Note that <span class="inlinecode"><span class="id" title="var">get</span></span> is
already of type <span class="inlinecode"><span class="id" title="var">nat_cell</span></span>, so it doesn't take any "visible" inputs. Of course,
the underlying implementation does take a <span class="inlinecode"><span class="id" title="var">cell_state</span></span> as input, but that is
"hidden" by the type of <span class="inlinecode"><span class="id" title="var">nat_cell</span></span>.)
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="NatCell.inc" class="idref" href="#NatCell.inc"><span class="id" title="definition">inc</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<a id="n:31" class="idref" href="#n:31"><span class="id" title="binder">n</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#NatCell.put"><span class="id" title="definition">put</span></a> (1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="Monads.html#n:31"><span class="id" title="variable">n</span></a>).<br/>
</div>

<div class="doc">
A generalization of <span class="inlinecode"><span class="id" title="var">cell_lt_two</span></span> that compares the cell value to a provided <span class="inlinecode"><span class="id" title="var">nat</span></span>: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="NatCell.lt" class="idref" href="#NatCell.lt"><span class="id" title="definition">lt</span></a> (<a id="m:32" class="idref" href="#m:32"><span class="id" title="binder">m</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<a id="n:33" class="idref" href="#n:33"><span class="id" title="binder">n</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.get"><span class="id" title="definition">get</span></a><a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#n:33"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#6b7621b45fff0af5e2b2cbb2bc2d4e1d"><span class="id" title="notation">&lt;?</span></a> <a class="idref" href="Monads.html#m:32"><span class="id" title="variable">m</span></a><a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
The sequence example can now be written as: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="NatCell.sequence_cell_example3" class="idref" href="#NatCell.sequence_cell_example3"><span class="id" title="definition">sequence_cell_example3</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<a id="b:34" class="idref" href="#b:34"><span class="id" title="binder">b</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.lt"><span class="id" title="definition">lt</span></a> 2<a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#b:34"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#NatCell.inc"><span class="id" title="definition">inc</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>
</div>

<div class="doc">
Although not using <span class="inlinecode"><span class="id" title="var">lt</span></span> yields code that is more similar to a standard imperative program: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="NatCell.sequence_cell_example4" class="idref" href="#NatCell.sequence_cell_example4"><span class="id" title="definition">sequence_cell_example4</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;<a id="n:35" class="idref" href="#n:35"><span class="id" title="binder">n</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> (<a class="idref" href="Monads.html#n:35"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#6b7621b45fff0af5e2b2cbb2bc2d4e1d"><span class="id" title="notation">&lt;?</span></a> 2)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#NatCell.inc"><span class="id" title="definition">inc</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>
</div>

<div class="doc">
We can still run the results, again by providing the initial state. 
</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example4"><span class="id" title="definition">sequence_cell_example4</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example4"><span class="id" title="definition">sequence_cell_example4</span></a> 1).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.sequence_cell_example4"><span class="id" title="definition">sequence_cell_example4</span></a> 2).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(2,</span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="NatCell.put_get_example" class="idref" href="#NatCell.put_get_example"><span class="id" title="definition">put_get_example</span></a> : <a class="idref" href="Monads.html#NatCell.nat_cell"><span class="id" title="definition">nat_cell</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">_</span> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.put"><span class="id" title="definition">put</span></a> 4 <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a id="x:36" class="idref" href="#x:36"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#NatCell.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#b930f6eeff2984dca0afb83564aaeb9a"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#x:36"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#ad2ec4e405f68c46c0a176e3e94ae2e<sub>3</sub>"><span class="id" title="notation">=?</span></a> 4<a class="idref" href="Monads.html#NatCell.:::'ret'_x"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#NatCell.put_get_example"><span class="id" title="definition">put_get_example</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(4,</span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#NatCell"><span class="id" title="module">NatCell</span></a>.<br/><hr class='doublespaceincode'/>

<br/>
</div>

<div class="doc">
<a id="lab143"></a><h2 class="section">Generalizing from <span class="inlinecode"><span class="id" title="var">nat</span></span> to arbitrary states</h2>

<div class="paragraph"> </div>

 We saw how to define the sequencing (<span class="inlinecode"><span class="id" title="var">bind</span></span>) and return operations for the
simple case of a mutable cell containing a natural number.  It is easy to
parametrize <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> to one that can work on arbitrary state. We call this new
definition <span class="inlinecode"><span class="id" title="var">state</span></span> because it will be the basis for our generic state monad
operations. 
<div class="paragraph"> </div>

 A stateful computation that returns a value of type <span class="inlinecode"><span class="id" title="var">B</span></span> takes a state <span class="inlinecode"><span class="id" title="var">S</span></span> as
  input and produces a (possibly updated state) along with the value of type <span class="inlinecode"><span class="id" title="var">B</span></span>.
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="State.state" class="idref" href="#State.state"><span class="id" title="definition">state</span></a> (<a id="S:37" class="idref" href="#S:37"><span class="id" title="binder">S</span></a> : <span class="id" title="keyword">Type</span>) (<a id="B:38" class="idref" href="#B:38"><span class="id" title="binder">B</span></a>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=  <a class="idref" href="Monads.html#S:37"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#S:37"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac<sub>4</sub>"><span class="id" title="notation">×</span></a> <a class="idref" href="Monads.html#B:38"><span class="id" title="variable">B</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 For any <span class="inlinecode"><span class="id" title="var">S</span></span>, the type <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> is a <i>monad</i>. 
<div class="paragraph"> </div>

 Denotation for Imp commands that produce no value:
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">state</span> <span class="id" title="var">mem</span> <span class="id" title="var">unit</span> = <span class="id" title="var">mem</span> → <span class="id" title="var">mem</span> × <span class="id" title="var">unit</span>
</span> 
<div class="paragraph"> </div>

    Denotation for Imp-like programs that produce a <span class="inlinecode"><span class="id" title="var">nat</span></span> value:
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">state</span> <span class="id" title="var">mem</span> <span class="id" title="var">nat</span> = <span class="id" title="var">mem</span> → <span class="id" title="var">mem</span> × <span class="id" title="var">nat</span>
</span><a id="lab144"></a><h3 class="section">Sequential composition of commands</h3>

<div class="paragraph"> </div>

 The state monad's <span class="inlinecode"><span class="id" title="var">bind</span></span> operation explicitly "plumbs" the state
  through the computation. It generalizes <span class="inlinecode"><span class="id" title="keyword">let</span></span>.
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="State.state_bind" class="idref" href="#State.state_bind"><span class="id" title="definition">state_bind</span></a> {<a id="S:39" class="idref" href="#S:39"><span class="id" title="binder">S</span></a> <a id="A:40" class="idref" href="#A:40"><span class="id" title="binder">A</span></a> <a id="B:41" class="idref" href="#B:41"><span class="id" title="binder">B</span></a>} (<a id="m:42" class="idref" href="#m:42"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:39"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#A:40"><span class="id" title="variable">A</span></a>) (<a id="k:43" class="idref" href="#k:43"><span class="id" title="binder">k</span></a>:<a class="idref" href="Monads.html#A:40"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:39"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#B:41"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:39"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#B:41"><span class="id" title="variable">B</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="3b2ad139708e05f42dd73db16efefbb8" class="idref" href="#3b2ad139708e05f42dd73db16efefbb8"><span class="id" title="binder">σ</span></a> ⇒ <span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>σ'<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">a</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#m:42"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3b2ad139708e05f42dd73db16efefbb8"><span class="id" title="variable">σ</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#k:43"><span class="id" title="variable">k</span></a> <span class="id" title="var">a</span> σ'.<br/>
</div>

<div class="doc">
We introduce some notation to make using <span class="inlinecode"><span class="id" title="var">bind</span></span> more palatable. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> "x &lt;- m ;; body" := (<a class="idref" href="Monads.html#State.state_bind"><span class="id" title="definition">state_bind</span></a> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <a id="x:45" class="idref" href="#x:45"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">body</span>))<br/><hr class='doublespaceincode'/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">ret</span></span> pairs a value <span class="inlinecode"><span class="id" title="var">a</span>:<span class="id" title="var">A</span></span> along with the initial state <span class="inlinecode">σ</span> -- it is
  a <span class="inlinecode"><span class="id" title="var">pure</span></span> computation that doesn't affect the state <span class="inlinecode">σ</span> 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="State.state_ret" class="idref" href="#State.state_ret"><span class="id" title="definition">state_ret</span></a> {<a id="S:46" class="idref" href="#S:46"><span class="id" title="binder">S</span></a> <a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a>} : <a class="idref" href="Monads.html#A:47"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:46"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#A:47"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="a:48" class="idref" href="#a:48"><span class="id" title="binder">a</span></a>:<a class="idref" href="Monads.html#A:47"><span class="id" title="variable">A</span></a>) (<a id="a5164b770c73878809c71cb845d5d280" class="idref" href="#a5164b770c73878809c71cb845d5d280"><span class="id" title="binder">σ</span></a>:<a class="idref" href="Monads.html#S:46"><span class="id" title="variable">S</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#a5164b770c73878809c71cb845d5d280"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#a:48"><span class="id" title="variable">a</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
We introduce some handy notation for returning values. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> "'ret' a" := (<a class="idref" href="Monads.html#State.state_ret"><span class="id" title="definition">state_ret</span></a> <span class="id" title="var">a</span>)<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
For the <span class="inlinecode"><span class="id" title="var">state</span></span> monad, the <span class="inlinecode"><span class="id" title="var">get</span></span> and <span class="inlinecode"><span class="id" title="var">put</span></span> operations work generically on any state. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">get</span></span> returns the current value of the state, leaving the state unchanged. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="State.get" class="idref" href="#State.get"><span class="id" title="definition">get</span></a> {<a id="S:50" class="idref" href="#S:50"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:50"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#S:50"><span class="id" title="variable">S</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="aabbb3071490a3e89c35c54fc4d8b7c<sub>4</sub>" class="idref" href="#aabbb3071490a3e89c35c54fc4d8b7c<sub>4</sub>"><span class="id" title="binder">σ</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#aabbb3071490a3e89c35c54fc4d8b7c<sub>4</sub>"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#aabbb3071490a3e89c35c54fc4d8b7c<sub>4</sub>"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">put</span></span> updates the state, returning the trivial <span class="inlinecode"><span class="id" title="var">unit</span></span> value. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="State.put" class="idref" href="#State.put"><span class="id" title="definition">put</span></a> {<a id="S:52" class="idref" href="#S:52"><span class="id" title="binder">S</span></a>} (<a id="a0f9183a4d32be3a7e3863d26ff4360e" class="idref" href="#a0f9183a4d32be3a7e3863d26ff4360e"><span class="id" title="binder">σ</span></a>:<a class="idref" href="Monads.html#S:52"><span class="id" title="variable">S</span></a>) : <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:52"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#a0f9183a4d32be3a7e3863d26ff4360e"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Our state monad can work on any state type, for example <span class="inlinecode"><span class="id" title="var">bool</span></span> state.
      Below, <span class="inlinecode"><span class="id" title="var">b</span></span> is the result of reading the state via <span class="inlinecode"><span class="id" title="var">get</span></span>, we use
      <span class="inlinecode"><span class="id" title="var">_</span></span> because the result of the <span class="inlinecode"><span class="id" title="var">put</span></span> operation is the trivial <span class="inlinecode"><span class="id" title="var">unit</span></span> value,
      and the computation returns <span class="inlinecode">3</span> if <span class="inlinecode"><span class="id" title="var">b</span></span> is <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode">17</span> otherwise.
   
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="State.boolean_state_example" class="idref" href="#State.boolean_state_example"><span class="id" title="definition">boolean_state_example</span></a> : <a class="idref" href="Monads.html#State.state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="b:54" class="idref" href="#b:54"><span class="id" title="binder">b</span></a> <a class="idref" href="Monads.html#2c3f73baa12e12743eb9fd6e6352afdb"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#State.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#2c3f73baa12e12743eb9fd6e6352afdb"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <a class="idref" href="Monads.html#2c3f73baa12e12743eb9fd6e6352afdb"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#State.put"><span class="id" title="definition">put</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Monads.html#b:54"><span class="id" title="variable">b</span></a>) <a class="idref" href="Monads.html#2c3f73baa12e12743eb9fd6e6352afdb"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#b:54"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#State.:::'ret'_x"><span class="id" title="notation">ret</span></a> 3 <span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#State.:::'ret'_x"><span class="id" title="notation">ret</span></a> 17.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#State.boolean_state_example"><span class="id" title="definition">boolean_state_example</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(<span class="id" title="var">false</span>,</span> <span class="inlinecode">3)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#State.boolean_state_example"><span class="id" title="definition">boolean_state_example</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">(<span class="id" title="var">true</span>,</span> <span class="inlinecode">17)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>

<div class="doc">
<a id="lab145"></a><h2 class="section">Options as a monad.</h2>

</div>

<div class="doc">
As we saw with mutable state, above, the key ingredients needed to define
  a monad are a notion of "sequential" composition and a notion of "returning" a
  value.  As another example, let us see how <span class="inlinecode"><span class="id" title="var">option</span></span> satisfies these
  requirements. 
<div class="paragraph"> </div>

 Recall that the values of type <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> include <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, where <span class="inlinecode"><span class="id" title="var">b</span></span> is a
  value of type <span class="inlinecode"><span class="id" title="var">B</span></span>, and <span class="inlinecode"><span class="id" title="var">None</span></span>.  We can think of <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> as a type that
  represents a computation of type <span class="inlinecode"><span class="id" title="var">B</span></span> that might fail (producing <span class="inlinecode"><span class="id" title="var">None</span></span> instead
  of a value).
  
<div class="paragraph"> </div>

<a id="lab146"></a><h3 class="section">Generalizing Return</h3>

<div class="paragraph"> </div>

 For <span class="inlinecode"><span class="id" title="var">option</span></span> it is easy to see what it means for a computation to "return" a value <span class="inlinecode"><span class="id" title="var">b</span></span>:
  it is simply <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>:
  
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="OptionMonad.option_ret" class="idref" href="#OptionMonad.option_ret"><span class="id" title="definition">option_ret</span></a> {<a id="B:55" class="idref" href="#B:55"><span class="id" title="binder">B</span></a>} (<a id="b:56" class="idref" href="#b:56"><span class="id" title="binder">b</span></a>:<a class="idref" href="Monads.html#B:55"><span class="id" title="variable">B</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#B:55"><span class="id" title="variable">B</span></a> := <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="Monads.html#b:56"><span class="id" title="variable">b</span></a>.<br/>
</div>

<div class="doc">
As before, we can introduce some handy notation for "returning" a value. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> "'ret' a" := (<a class="idref" href="Monads.html#OptionMonad.option_ret"><span class="id" title="definition">option_ret</span></a> <span class="id" title="var">a</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50).<br/>
</div>

<div class="doc">
This lets us define a successful computation as returning a result.  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.returns_three" class="idref" href="#OptionMonad.returns_three"><span class="id" title="definition">returns_three</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> := <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> 3.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.returns_three"><span class="id" title="definition">returns_three</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode">3</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

 (You might wonder, given the definition above, why we don't just use <span class="inlinecode"><span class="id" title="var">Some</span></span>.
  That would be type correct, but introducing consistent notation for monads will
  make it easier to write general-purpose code that works for <i>any</i> monad.  We
  will introduce such a typeclass shortly.)  
<div class="paragraph"> </div>

 As another example, the following function, given <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">nat</span></span>, produces a
  computation that always succeeds, returning a <span class="inlinecode"><span class="id" title="var">bool</span></span> indicating whether <span class="inlinecode"><span class="id" title="var">n</span></span> ia
  equal to <span class="inlinecode">3</span>: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.is_three_succeeds" class="idref" href="#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> (<a id="n:57" class="idref" href="#n:57"><span class="id" title="binder">n</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#n:57"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#ad2ec4e405f68c46c0a176e3e94ae2e<sub>3</sub>"><span class="id" title="notation">=?</span></a> 3 <span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> 3).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

 Because we want to think of <span class="inlinecode"><span class="id" title="var">None</span></span> as a "failing" computation, we also
  introduce some notation that makes that point of view clear: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a id="OptionMonad.:::'fail'" class="idref" href="#OptionMonad.:::'fail'"><span class="id" title="notation">&quot;</span></a>'fail'" := <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>
</div>

<div class="doc">
Now we can define a function the sometimes fails and sometimes succeeds,
  depending on its input: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.fail_if_zero" class="idref" href="#OptionMonad.fail_if_zero"><span class="id" title="definition">fail_if_zero</span></a> (<a id="n:58" class="idref" href="#n:58"><span class="id" title="binder">n</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#n:58"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#ad2ec4e405f68c46c0a176e3e94ae2e<sub>3</sub>"><span class="id" title="notation">=?</span></a>0 <span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="Monads.html#n:58"><span class="id" title="variable">n</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.fail_if_zero"><span class="id" title="definition">fail_if_zero</span></a> 0).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="tactic">fail</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.fail_if_zero"><span class="id" title="definition">fail_if_zero</span></a> 3).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode">3</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

<a id="lab147"></a><h3 class="section">Generalizing <span class="inlinecode"><span class="id" title="keyword">let</span></span>: <span class="inlinecode"><span class="id" title="var">bind</span></span> for <span class="inlinecode"><span class="id" title="var">option</span></span></h3>

<div class="paragraph"> </div>

 Now suppose that we have a computation <span class="inlinecode"><span class="id" title="var">m</span></span> of type <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> and we want
  to sequence it before one of the two examples above. If <span class="inlinecode"><span class="id" title="var">m</span></span> fails, the
  whole sequenced computation should also fail--there is no result to feed
  to the next step.  
</div>
<div class="code">

&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.seq_is_three_succeeds" class="idref" href="#OptionMonad.seq_is_three_succeeds"><span class="id" title="definition">seq_is_three_succeeds</span></a> (<a id="m:59" class="idref" href="#m:59"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Monads.html#m:59"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a> ⇒ <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Monads.html#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
When we run <span class="inlinecode"><span class="id" title="var">seq_is_three_succeeds</span></span> on a successful computation that
  returns <span class="inlinecode">3</span> we get: 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.seq_is_three_succeeds"><span class="id" title="definition">seq_is_three_succeeds</span></a> <a class="idref" href="Monads.html#OptionMonad.returns_three"><span class="id" title="definition">returns_three</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

 When we run it on a successful computation that returns <span class="inlinecode">0</span> we get: 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.seq_is_three_succeeds"><span class="id" title="definition">seq_is_three_succeeds</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> 0)).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

 On the other hand, running it on a failing computation we get: 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.seq_is_three_succeeds"><span class="id" title="definition">seq_is_three_succeeds</span></a> <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="tactic">fail</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

 As with state, we can define <span class="inlinecode"><span class="id" title="var">bind</span></span> to be the general, sequential
  composition of operation:
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="OptionMonad.option_bind" class="idref" href="#OptionMonad.option_bind"><span class="id" title="definition">option_bind</span></a> {<a id="A:61" class="idref" href="#A:61"><span class="id" title="binder">A</span></a> <a id="B:62" class="idref" href="#B:62"><span class="id" title="binder">B</span></a>} (<a id="m:63" class="idref" href="#m:63"><span class="id" title="binder">m</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#A:61"><span class="id" title="variable">A</span></a>) (<a id="k:64" class="idref" href="#k:64"><span class="id" title="binder">k</span></a> : <a class="idref" href="Monads.html#A:61"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#B:62"><span class="id" title="variable">B</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#B:62"><span class="id" title="variable">B</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Monads.html#m:63"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a> ⇒ <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">a</span> ⇒ <a class="idref" href="Monads.html#k:64"><span class="id" title="variable">k</span></a> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
And re-use the <span class="inlinecode"><span class="id" title="keyword">let</span></span>-inspired notation from earlier: 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> "x &lt;- m ;; rest" := (<a class="idref" href="Monads.html#OptionMonad.option_bind"><span class="id" title="definition">option_bind</span></a> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <a id="x:66" class="idref" href="#x:66"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">rest</span>))<br/>
</div>

<div class="doc">
Now we can write some examples more cleanly: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.seq_is_three_succeeds'" class="idref" href="#OptionMonad.seq_is_three_succeeds'"><span class="id" title="definition">seq_is_three_succeeds'</span></a> (<a id="m:67" class="idref" href="#m:67"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="n:68" class="idref" href="#n:68"><span class="id" title="binder">n</span></a> <a class="idref" href="Monads.html#565e76b1b0e78e5c10fc2072c0471609"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:67"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#565e76b1b0e78e5c10fc2072c0471609"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> <a class="idref" href="Monads.html#n:68"><span class="id" title="variable">n</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.seq_is_three_succeeds'"><span class="id" title="definition">seq_is_three_succeeds'</span></a> <a class="idref" href="Monads.html#OptionMonad.returns_three"><span class="id" title="definition">returns_three</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.seq_is_three_succeeds'"><span class="id" title="definition">seq_is_three_succeeds'</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> 0)).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.seq_is_three_succeeds'"><span class="id" title="definition">seq_is_three_succeeds'</span></a> <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="tactic">fail</span></span> 
<div class="paragraph"> </div>

 This notation really shines when there are several operations in sequence,
  because each <span class="inlinecode"><span class="id" title="var">bind</span></span> expands to (nested) pattern matches.  For instance: 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.bigger_sequence" class="idref" href="#OptionMonad.bigger_sequence"><span class="id" title="definition">bigger_sequence</span></a> (<a id="m:69" class="idref" href="#m:69"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="n:70" class="idref" href="#n:70"><span class="id" title="binder">n</span></a> <a class="idref" href="Monads.html#565e76b1b0e78e5c10fc2072c0471609"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:69"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#565e76b1b0e78e5c10fc2072c0471609"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="n':71" class="idref" href="#n':71"><span class="id" title="binder">n'</span></a> <a class="idref" href="Monads.html#565e76b1b0e78e5c10fc2072c0471609"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#OptionMonad.fail_if_zero"><span class="id" title="definition">fail_if_zero</span></a> <a class="idref" href="Monads.html#n:70"><span class="id" title="variable">n</span></a> <a class="idref" href="Monads.html#565e76b1b0e78e5c10fc2072c0471609"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> <a class="idref" href="Monads.html#n':71"><span class="id" title="variable">n'</span></a>.<br/>
</div>

<div class="doc">
Is much easier to read than this :
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.bigger_sequence_desugared" class="idref" href="#OptionMonad.bigger_sequence_desugared"><span class="id" title="definition">bigger_sequence_desugared</span></a> (<a id="m:72" class="idref" href="#m:72"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Monads.html#m:72"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a> ⇒ <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">n</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Monads.html#OptionMonad.fail_if_zero"><span class="id" title="definition">fail_if_zero</span></a> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a> ⇒ <a class="idref" href="Monads.html#OptionMonad.:::'fail'"><span class="id" title="notation">fail</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">n'</span> ⇒ <a class="idref" href="Monads.html#OptionMonad.is_three_succeeds"><span class="id" title="definition">is_three_succeeds</span></a> <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.bigger_sequence"><span class="id" title="definition">bigger_sequence</span></a> <a class="idref" href="Monads.html#OptionMonad.returns_three"><span class="id" title="definition">returns_three</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.bigger_sequence"><span class="id" title="definition">bigger_sequence</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> 0)).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="tactic">fail</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#OptionMonad.bigger_sequence"><span class="id" title="definition">bigger_sequence</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> 17)).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 
<div class="paragraph"> </div>

 EX<sub>1</sub> (example_option_and ) 
<div class="paragraph"> </div>

 Write an <span class="inlinecode"><span class="id" title="var">option</span></span> monad computation that returns the logical "and" of
      the two values returned by <span class="inlinecode"><span class="id" title="var">m<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">m<sub>2</sub></span></span> and fails if either <span class="inlinecode"><span class="id" title="var">m<sub>1</sub></span></span> or
      <span class="inlinecode"><span class="id" title="var">m<sub>2</sub></span></span> fails. You can use <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> to compute the result.
      Your version should pass all the tests below.
  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.example_option_and" class="idref" href="#OptionMonad.example_option_and"><span class="id" title="definition">example_option_and</span></a> (<a id="m<sub>1</sub>:74" class="idref" href="#m<sub>1</sub>:74"><span class="id" title="binder">m<sub>1</sub></span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) (<a id="m<sub>2</sub>:75" class="idref" href="#m<sub>2</sub>:75"><span class="id" title="binder">m<sub>2</sub></span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;":=&nbsp;_your_definition_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.test_example_option_and1" class="idref" href="#OptionMonad.test_example_option_and1"><span class="id" title="definition">test_example_option_and1</span></a>: <a class="idref" href="Monads.html#OptionMonad.example_option_and"><span class="id" title="axiom">example_option_and</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.test_example_option_and2" class="idref" href="#OptionMonad.test_example_option_and2"><span class="id" title="definition">test_example_option_and2</span></a>: <a class="idref" href="Monads.html#OptionMonad.example_option_and"><span class="id" title="axiom">example_option_and</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.test_example_option_and3" class="idref" href="#OptionMonad.test_example_option_and3"><span class="id" title="definition">test_example_option_and3</span></a>: <a class="idref" href="Monads.html#OptionMonad.example_option_and"><span class="id" title="axiom">example_option_and</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a id="OptionMonad.test_example_option_and4" class="idref" href="#OptionMonad.test_example_option_and4"><span class="id" title="definition">test_example_option_and4</span></a>: <a class="idref" href="Monads.html#OptionMonad.example_option_and"><span class="id" title="axiom">example_option_and</span></a> (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) (<a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#OptionMonad.:::'ret'_x"><span class="id" title="notation">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab148"></a><h2 class="section">Monads, generally</h2>

</div>

<div class="doc">
So far we have seen three instances of monads: <span class="inlinecode"><span class="id" title="var">nat_cell</span></span>, <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span>, and
<span class="inlinecode"><span class="id" title="var">option</span></span>. Note that each of these is a <i>parameterized type</i>, they have kind
<span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.  The common abstraction linking them is that they represent
computations that can be composed in sequence.  In general, a monad <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
is a parameterized type for which we think of <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> as representing "(potentially)
impure computations that return an <span class="inlinecode"><span class="id" title="var">A</span></span>".  Moreover, <span class="inlinecode"><span class="id" title="var">M</span></span> must support: 
<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">ret</span></span>, a way to embed <i>pure</i> computations, and

</li>
<li> <span class="inlinecode"><span class="id" title="var">bind</span></span>, a way to <i>sequence</i> computations.

</li>
</ul>

<div class="paragraph"> </div>

 We also saw that each of our example monads supported additional operations that
are unique to their types--they each represent a specific kind of "impure"
computation. The <span class="inlinecode"><span class="id" title="var">nat_cell</span></span> and <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> monads support <span class="inlinecode"><span class="id" title="var">get</span></span> and <span class="inlinecode"><span class="id" title="var">put</span></span>
operations that access the state.  The <span class="inlinecode"><span class="id" title="var">option</span></span> monad supports <span class="inlinecode"><span class="id" title="tactic">fail</span></span>, a computation
that fails.  The <span class="inlinecode"><span class="id" title="var">bind</span></span> operation propagates the monad-specific information through
the sequencing.
<div class="paragraph"> </div>

 Because all monads support <span class="inlinecode"><span class="id" title="var">ret</span></span> and <span class="inlinecode"><span class="id" title="var">bind</span></span>, we can define those operations
as a typeclass, which will allow us to overload those operations and (soon)
to define lemmas that work generically for <i>any</i> monad. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Class</span> <a id="Monad.Monad" class="idref" href="#Monad.Monad"><span class="id" title="record">Monad</span></a> (<a id="M:76" class="idref" href="#M:76"><span class="id" title="binder">M</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="Monad.ret" class="idref" href="#Monad.ret"><span class="id" title="projection">ret</span></a>  : <span class="id" title="keyword">∀</span> <a id="A:78" class="idref" href="#A:78"><span class="id" title="binder">A</span></a>, <a class="idref" href="Monads.html#A:78"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:76"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:78"><span class="id" title="variable">A</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="Monad.bind" class="idref" href="#Monad.bind"><span class="id" title="projection">bind</span></a> : <span class="id" title="keyword">∀</span> <a id="A:80" class="idref" href="#A:80"><span class="id" title="binder">A</span></a> <a id="B:81" class="idref" href="#B:81"><span class="id" title="binder">B</span></a>, <a class="idref" href="Monads.html#M:76"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:80"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#A:80"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:76"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:81"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:76"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:81"><span class="id" title="variable">B</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
For an arbitrary monad <span class="inlinecode"><span class="id" title="var">M</span></span>, <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> is an effectful computation computing a
    <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">ret</span></span> <span class="inlinecode">(3</span> <span class="inlinecode">+</span> <span class="inlinecode">4)</span> is the pure computation computing <span class="inlinecode">3</span> <span class="inlinecode">+</span> <span class="inlinecode">4</span>, and <span class="inlinecode"><span class="id" title="var">bind</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>
    performs <span class="inlinecode"><span class="id" title="var">m</span></span>, gets its result, feeds it to <span class="inlinecode"><span class="id" title="var">k</span></span> and continues. 
<div class="paragraph"> </div>

<a id="lab149"></a><h3 class="section">Monad Notations</h3>

<div class="paragraph"> </div>

 We can recapitulate our helpful notations from earlier, along with a couple
variants that make programming with monads more natural. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Monad.MonadNotation" class="idref" href="#Monad.MonadNotation"><span class="id" title="module">MonadNotation</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;#[<span class="id" title="var">export</span>]<br/>
&nbsp;&nbsp;<span class="id" title="var">Declare</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">monad_scope</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">monad_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">monad</span>.<br/>
</div>

<div class="doc">
The standard monadic sequencing operation in terms of <span class="inlinecode"><span class="id" title="var">bind</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a id="3786188b3014de23a57c889c5f8409fc" class="idref" href="#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&quot;</span></a>x &lt;- m ;; k" := (@<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <a id="x:83" class="idref" href="#x:83"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">k</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 61, <span class="id" title="var">m</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">monad_scope</span>.<br/>
</div>

<div class="doc">
A version that ignores the result from the first computation. Useful
   when <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">unit</span></span> 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a id="1da0769dc49b3c22924058237ab38059" class="idref" href="#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">&quot;</span></a>m ;; k" := (@<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">m</span>%<span class="id" title="var">monad</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">k</span>%<span class="id" title="var">monad</span>))%<span class="id" title="var">monad</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 61, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">monad_scope</span>.<br/>
</div>

<div class="doc">
A version that allows Coq's pattern matching notation to be used
   for the binder.  Useful when the computation returns a tuple.
  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a id="e99f52892ff456da65b7dc7156f3b770" class="idref" href="#e99f52892ff456da65b7dc7156f3b770"><span class="id" title="notation">&quot;</span></a>' pat &lt;- m ;; k" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <a id="x:84" class="idref" href="#x:84"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Monads.html#x:84"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">pat</span> ⇒ <span class="id" title="var">k</span> <span class="id" title="keyword">end</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 61, <span class="id" title="var">pat</span> <span class="id" title="tactic">pattern</span>, <span class="id" title="var">m</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">monad_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#Monad.MonadNotation"><span class="id" title="module">MonadNotation</span></a>.<br/>
</div>

<div class="doc">
<a id="lab150"></a><h2 class="section">Monad Instances</h2>

<div class="paragraph"> </div>

<a id="lab151"></a><h3 class="section">Option</h3>
 Computations that may fail can be modeled using the option monad 
</div>
<div class="code">
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="Monad.OptionM" class="idref" href="#Monad.OptionM"><span class="id" title="instance">OptionM</span></a> : <a class="idref" href="Monads.html#Monad.Monad"><span class="id" title="class">Monad</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> :=<br/>
{|<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> := <span class="id" title="keyword">fun</span> <a id="A:86" class="idref" href="#A:86"><span class="id" title="binder">A</span></a> (<a id="a:87" class="idref" href="#a:87"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:86"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="Monads.html#a:87"><span class="id" title="variable">a</span></a>;<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> := <span class="id" title="keyword">fun</span> <a id="A:88" class="idref" href="#A:88"><span class="id" title="binder">A</span></a> <a id="B:89" class="idref" href="#B:89"><span class="id" title="binder">B</span></a> <a id="m:90" class="idref" href="#m:90"><span class="id" title="binder">m</span></a> <a id="k:91" class="idref" href="#k:91"><span class="id" title="binder">k</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Monads.html#m:90"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Monads.html#k:91"><span class="id" title="variable">k</span></a> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
|}.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="Monad.:::'fail'" class="idref" href="#Monad.:::'fail'"><span class="id" title="notation">&quot;</span></a>'fail'" := <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>
</div>

<div class="doc">
And the one that initiated our exploration: stateful computations can use the state monad 
<div class="paragraph"> </div>

<a id="lab152"></a><h3 class="section">State instance of the Monad Typeclass</h3>

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="Monad.state" class="idref" href="#Monad.state"><span class="id" title="definition">state</span></a> (<a id="S:93" class="idref" href="#S:93"><span class="id" title="binder">S</span></a>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span> := <span class="id" title="keyword">fun</span> <a id="A:94" class="idref" href="#A:94"><span class="id" title="binder">A</span></a> ⇒ <a class="idref" href="Monads.html#S:93"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#S:93"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac<sub>4</sub>"><span class="id" title="notation">×</span></a> <a class="idref" href="Monads.html#A:94"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="Monad.stateM" class="idref" href="#Monad.stateM"><span class="id" title="instance">stateM</span></a> <a id="S:95" class="idref" href="#S:95"><span class="id" title="binder">S</span></a> : <a class="idref" href="Monads.html#Monad.Monad"><span class="id" title="class">Monad</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:95"><span class="id" title="variable">S</span></a>) :=<br/>
&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a>  := <span class="id" title="keyword">fun</span> <a id="A:96" class="idref" href="#A:96"><span class="id" title="binder">A</span></a> (<a id="a:97" class="idref" href="#a:97"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:96"><span class="id" title="variable">A</span></a>) <a id="cc6b043719e4d47de25e406f4c2e0c<sub>05</sub>" class="idref" href="#cc6b043719e4d47de25e406f4c2e0c<sub>05</sub>"><span class="id" title="binder">σ</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#cc6b043719e4d47de25e406f4c2e0c<sub>05</sub>"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#a:97"><span class="id" title="variable">a</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> := <span class="id" title="keyword">fun</span> <a id="A:99" class="idref" href="#A:99"><span class="id" title="binder">A</span></a> <a id="B:100" class="idref" href="#B:100"><span class="id" title="binder">B</span></a> (<a id="m:101" class="idref" href="#m:101"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <span class="id" title="var">S</span> <a class="idref" href="Monads.html#A:99"><span class="id" title="variable">A</span></a>) (<a id="k:102" class="idref" href="#k:102"><span class="id" title="binder">k</span></a> : <a class="idref" href="Monads.html#A:99"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <span class="id" title="var">S</span> <a class="idref" href="Monads.html#B:100"><span class="id" title="variable">B</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="7ebcfa9c1e384da68c82f37dc2702491" class="idref" href="#7ebcfa9c1e384da68c82f37dc2702491"><span class="id" title="binder">σ</span></a> ⇒ <span class="id" title="keyword">let</span> '<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>σ'<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">a</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> := <a class="idref" href="Monads.html#m:101"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#7ebcfa9c1e384da68c82f37dc2702491"><span class="id" title="variable">σ</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#k:102"><span class="id" title="variable">k</span></a> <span class="id" title="var">a</span> σ'<br/>
&nbsp;&nbsp;|}.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="Monad.get" class="idref" href="#Monad.get"><span class="id" title="definition">get</span></a> {<a id="S:104" class="idref" href="#S:104"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:104"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#S:104"><span class="id" title="variable">S</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="a255feff7b2e62ba2eca44b34f92eb<sub>33</sub>" class="idref" href="#a255feff7b2e62ba2eca44b34f92eb<sub>33</sub>"><span class="id" title="binder">σ</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#a255feff7b2e62ba2eca44b34f92eb<sub>33</sub>"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#a255feff7b2e62ba2eca44b34f92eb<sub>33</sub>"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="Monad.put" class="idref" href="#Monad.put"><span class="id" title="definition">put</span></a> {<a id="S:106" class="idref" href="#S:106"><span class="id" title="binder">S</span></a>} (<a id="ccfcad0f5f2d68e724a3fa1bd4913fee" class="idref" href="#ccfcad0f5f2d68e724a3fa1bd4913fee"><span class="id" title="binder">σ</span></a>:<a class="idref" href="Monads.html#S:106"><span class="id" title="variable">S</span></a>) : <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:106"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#ccfcad0f5f2d68e724a3fa1bd4913fee"><span class="id" title="variable">σ</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
<a id="lab153"></a><h3 class="section">Identity</h3>
 Pure computations can be seen as computations in the <i>identity monad</i>, in which
<span class="inlinecode"><span class="id" title="var">bind</span></span> is just function application.  (This is a useful "base case" for some
constructions involving maps between monads.)
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="Monad.id" class="idref" href="#Monad.id"><span class="id" title="definition">id</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span> := <span class="id" title="keyword">fun</span> <a id="X:108" class="idref" href="#X:108"><span class="id" title="binder">X</span></a> ⇒ <a class="idref" href="Monads.html#X:108"><span class="id" title="variable">X</span></a>.<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="Monad.IdM" class="idref" href="#Monad.IdM"><span class="id" title="instance">IdM</span></a> : <a class="idref" href="Monads.html#Monad.Monad"><span class="id" title="class">Monad</span></a> <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a> :=<br/>
{|<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> := <span class="id" title="keyword">fun</span> <a id="A:109" class="idref" href="#A:109"><span class="id" title="binder">A</span></a> (<a id="a:110" class="idref" href="#a:110"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:109"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="Monads.html#a:110"><span class="id" title="variable">a</span></a>;<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> := <span class="id" title="keyword">fun</span> <a id="A:111" class="idref" href="#A:111"><span class="id" title="binder">A</span></a> <a id="B:112" class="idref" href="#B:112"><span class="id" title="binder">B</span></a> <a id="a:113" class="idref" href="#a:113"><span class="id" title="binder">a</span></a> <a id="f:114" class="idref" href="#f:114"><span class="id" title="binder">f</span></a> ⇒ <a class="idref" href="Monads.html#f:114"><span class="id" title="variable">f</span></a> <a class="idref" href="Monads.html#a:113"><span class="id" title="variable">a</span></a>;<br/>
|}.<br/>
</div>

<div class="doc">
<a id="lab154"></a><h3 class="section">Nondeterminism</h3>
 We can define a "nondeterminism" monad whose computation type is given by <span class="inlinecode"><span class="id" title="var">list</span></span>.
   We can think of a computation in this monad as (nondeterministically) exploring
   all possible combinations of values in the list.
 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="Monad.nondet" class="idref" href="#Monad.nondet"><span class="id" title="definition">nondet</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span> := <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a>.<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="Monad.NonDetM" class="idref" href="#Monad.NonDetM"><span class="id" title="instance">NonDetM</span></a> : <a class="idref" href="Monads.html#Monad.Monad"><span class="id" title="class">Monad</span></a> <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a> :=<br/>
{|<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a>  := <span class="id" title="keyword">fun</span> <a id="A:115" class="idref" href="#A:115"><span class="id" title="binder">A</span></a> (<a id="a:116" class="idref" href="#a:116"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:115"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#ddd65c2f7ee73ecec433744948d846bb"><span class="id" title="notation">[</span></a><a class="idref" href="Monads.html#a:116"><span class="id" title="variable">a</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#ddd65c2f7ee73ecec433744948d846bb"><span class="id" title="notation">]</span></a>;<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a> := <span class="id" title="keyword">fun</span> <a id="A:117" class="idref" href="#A:117"><span class="id" title="binder">A</span></a> <a id="B:118" class="idref" href="#B:118"><span class="id" title="binder">B</span></a> (<a id="m:119" class="idref" href="#m:119"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a> <a class="idref" href="Monads.html#A:117"><span class="id" title="variable">A</span></a>) (<a id="k:120" class="idref" href="#k:120"><span class="id" title="binder">k</span></a> : <a class="idref" href="Monads.html#A:117"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a> <a class="idref" href="Monads.html#B:118"><span class="id" title="variable">B</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#flat_map"><span class="id" title="definition">List.flat_map</span></a> <a class="idref" href="Monads.html#k:120"><span class="id" title="variable">k</span></a> <a class="idref" href="Monads.html#m:119"><span class="id" title="variable">m</span></a><br/>
|}.<br/>
</div>

<div class="doc">
The "effectful" operation of this monad is an operation that chooses
nondeterministically from among a list of possibilities. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="Monad.choose" class="idref" href="#Monad.choose"><span class="id" title="definition">choose</span></a> {<a id="A:121" class="idref" href="#A:121"><span class="id" title="binder">A</span></a>} (<a id="choices:122" class="idref" href="#choices:122"><span class="id" title="binder">choices</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Monads.html#A:121"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a> <a class="idref" href="Monads.html#A:121"><span class="id" title="variable">A</span></a> := <a class="idref" href="Monads.html#choices:122"><span class="id" title="variable">choices</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Import</span> <a class="idref" href="Monads.html#Monad.MonadNotation"><span class="id" title="module">MonadNotation</span></a>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">monad_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a id="Monad.decode_bits_example" class="idref" href="#Monad.decode_bits_example"><span class="id" title="definition">decode_bits_example</span></a> : <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<a id="b<sub>0</sub>:123" class="idref" href="#b<sub>0</sub>:123"><span class="id" title="binder">b<sub>0</sub></span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.choose"><span class="id" title="definition">choose</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a>0<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a id="b<sub>1</sub>:124" class="idref" href="#b<sub>1</sub>:124"><span class="id" title="binder">b<sub>1</sub></span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.choose"><span class="id" title="definition">choose</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a>0<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#b<sub>1</sub>:124"><span class="id" title="variable">b<sub>1</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Monads.html#b<sub>0</sub>:123"><span class="id" title="variable">b<sub>0</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> 0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> ⇒ <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 0<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> ⇒ <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 1<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> 0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> ⇒ <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 2<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a>1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> ⇒ <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 3<br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="Monads.html#Monad.choose"><span class="id" title="definition">choose</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#ae9a5e1034e143b218b09d8e454472bd"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#Monad.decode_bits_example"><span class="id" title="definition">decode_bits_example</span></a>.<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode"></span> <span class="inlinecode">[0;</span> <span class="inlinecode">2;</span> <span class="inlinecode">1;</span> <span class="inlinecode">3]</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span>
</div>

<div class="doc">
<a id="lab155"></a><h2 class="section">Monad Laws</h2>

</div>

<div class="doc">
When we introduced the idea of generalizing sequential composition above, we
noted that <span class="inlinecode"><span class="id" title="var">ret</span></span> and <span class="inlinecode"><span class="id" title="var">bind</span></span> should be "well-behaved".  What, exactly, does that
mean?

<div class="paragraph"> </div>

In the case of sequential composition of imperative code, one property we would
expect is that the way in which we group commands with <span class="inlinecode">';'</span> doesn't matter,
namely we expect that <span class="inlinecode">(<span class="id" title="var">c<sub>1</sub></span></span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" title="var">c<sub>2</sub></span>)</span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" title="var">c<sub>3</sub></span></span> and <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span></span> <span class="inlinecode">;</span> <span class="inlinecode">(<span class="id" title="var">c<sub>2</sub></span></span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" title="var">c<sub>3</sub></span>)</span> should mean the same
thing.  That is, seqencing is an <i>associative</i> operation.

<div class="paragraph"> </div>

In the case of <span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding, the idea of "associativity" needs to be slightly
generalized to account for the scope of the variable bindings.  But we can still
see the same structure.  Consider the following two Gallina terms:

</div>
<div class="code">
<hr class='doublespaceincode'/>

<br/>
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets1" class="idref" href="#MonadLawsEq.nested_lets1"><span class="id" title="definition">nested_lets1</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="x:126" class="idref" href="#x:126"><span class="id" title="binder">x</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">let</span> <a id="y:125" class="idref" href="#y:125"><span class="id" title="binder">y</span></a> := 3 <span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#y:125"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Monads.html#y:125"><span class="id" title="variable">y</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#x:126"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2 .<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets2" class="idref" href="#MonadLawsEq.nested_lets2"><span class="id" title="definition">nested_lets2</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="y:127" class="idref" href="#y:127"><span class="id" title="binder">y</span></a> := 3 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="x:128" class="idref" href="#x:128"><span class="id" title="binder">x</span></a> := <a class="idref" href="Monads.html#y:127"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Monads.html#y:127"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#x:128"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2.<br/>
</div>

<div class="doc">
Both of these expressions evaluate to the <i>same</i> value: 
</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#MonadLawsEq.nested_lets1"><span class="id" title="definition">nested_lets1</span></a>.<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">12</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#MonadLawsEq.nested_lets2"><span class="id" title="definition">nested_lets2</span></a>.<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">12</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

 Using the identity <span class="inlinecode"><span class="id" title="var">id</span></span> monad, we can even write these examples using our
monad notation directly: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets_monadic1" class="idref" href="#MonadLawsEq.nested_lets_monadic1"><span class="id" title="definition">nested_lets_monadic1</span></a> : <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<a id="x:130" class="idref" href="#x:130"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:129" class="idref" href="#y:129"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 3 <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#y:129"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="Monads.html#y:129"><span class="id" title="variable">y</span></a>)<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:130"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets_monadic2" class="idref" href="#MonadLawsEq.nested_lets_monadic2"><span class="id" title="definition">nested_lets_monadic2</span></a> : <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<a id="y:131" class="idref" href="#y:131"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 3 <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a id="x:132" class="idref" href="#x:132"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#y:131"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Monads.html#y:131"><span class="id" title="variable">y</span></a>) <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:132"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#MonadLawsEq.nested_lets_monadic1"><span class="id" title="definition">nested_lets_monadic1</span></a>.<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">12</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Monads.html#MonadLawsEq.nested_lets_monadic2"><span class="id" title="definition">nested_lets_monadic2</span></a>.<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">12</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

 Thus, the first property that we expect to hold of a "well-behaved" monad is
that <span class="inlinecode"><span class="id" title="var">bind</span></span> is <i>associative</i>. For <span class="inlinecode"><span class="id" title="keyword">let</span></span>-bindings, this means that we can
"un-nest" them, floating inner bindings outward.  For other monadic
computations, it means that the the behavior truly is sequential.  In words:
"doing <span class="inlinecode"><span class="id" title="var">a</span></span> before doing <span class="inlinecode"><span class="id" title="var">b</span></span> and then <span class="inlinecode"><span class="id" title="var">c</span></span>" is the <i>same</i> as "doing <span class="inlinecode"><span class="id" title="var">a</span></span> then <span class="inlinecode"><span class="id" title="var">b</span></span>
before doing <span class="inlinecode"><span class="id" title="var">c</span></span>".

<div class="paragraph"> </div>

We can write this down as a (first attempt at a) general law about monads as
follows: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="MonadLawsEq.bind_associativity_law" class="idref" href="#MonadLawsEq.bind_associativity_law"><span class="id" title="definition">bind_associativity_law</span></a> {<a id="M:133" class="idref" href="#M:133"><span class="id" title="binder">M</span></a>} `{<a id="H:134" class="idref" href="#H:134"><span class="id" title="binder">Monad</span></a> <a id="H:134" class="idref" href="#H:134"><span class="id" title="binder">M</span></a>} {<a id="A:135" class="idref" href="#A:135"><span class="id" title="binder">A</span></a> <a id="B:136" class="idref" href="#B:136"><span class="id" title="binder">B</span></a> <a id="C:137" class="idref" href="#C:137"><span class="id" title="binder">C</span></a>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="ma:138" class="idref" href="#ma:138"><span class="id" title="binder">ma</span></a> : <a class="idref" href="Monads.html#M:133"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:135"><span class="id" title="variable">A</span></a>) (<a id="kb:139" class="idref" href="#kb:139"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:135"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:133"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:136"><span class="id" title="variable">B</span></a>) (<a id="kc:140" class="idref" href="#kc:140"><span class="id" title="binder">kc</span></a> : <a class="idref" href="Monads.html#B:136"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:133"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#C:137"><span class="id" title="variable">C</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:142" class="idref" href="#x:142"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:141" class="idref" href="#y:141"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:138"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:139"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:141"><span class="id" title="variable">y</span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:140"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:142"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="y:143" class="idref" href="#y:143"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:138"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a id="x:144" class="idref" href="#x:144"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#kb:139"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:143"><span class="id" title="variable">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:140"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:144"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
Taking a closer look at the examples above suggest another property that we
would expect to hold.  If we think about the operational behavior of a
<span class="inlinecode"><span class="id" title="keyword">let</span></span>-binding, we expect to have a <i>substitution</i> property, namely, that we an
replace the <span class="inlinecode"><span class="id" title="keyword">let</span></span>-bound variable with its definition. For example, consider
what happens if we substitute <span class="inlinecode">3</span> for <span class="inlinecode"><span class="id" title="var">y</span></span> when evaluating <span class="inlinecode"><span class="id" title="var">nested_lets2</span></span>. We get: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets_monadic2'" class="idref" href="#MonadLawsEq.nested_lets_monadic2'"><span class="id" title="definition">nested_lets_monadic2'</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="y:145" class="idref" href="#y:145"><span class="id" title="binder">y</span></a> := 3 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="x:146" class="idref" href="#x:146"><span class="id" title="binder">x</span></a> := <a class="idref" href="Monads.html#y:145"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Monads.html#y:145"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#x:146"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets2_subst" class="idref" href="#MonadLawsEq.nested_lets2_subst"><span class="id" title="definition">nested_lets2_subst</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="x:147" class="idref" href="#x:147"><span class="id" title="binder">x</span></a> := 3 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 3 <span class="id" title="keyword">in</span>    <span class="comment">(*&nbsp;n.b.&nbsp;substitute&nbsp;<span class="inlinecode">3</span>&nbsp;for&nbsp;<span class="inlinecode"><span class="id" title="var">y</span></span>&nbsp;in&nbsp;&nbsp;<span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#x:147"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2.<br/>
</div>

<div class="doc">
After the substitution, we still obtain the same result: 
</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="Monads.html#MonadLawsEq.nested_lets2_subst"><span class="id" title="definition">nested_lets2_subst</span></a>).<br/>
</div>

<div class="doc">
==&gt; <span class="inlinecode">12</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
<div class="paragraph"> </div>

 Looking at the same computation expressed using the <span class="inlinecode"><span class="id" title="var">id</span></span> monad gives us: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets_monadic2_subst" class="idref" href="#MonadLawsEq.nested_lets_monadic2_subst"><span class="id" title="definition">nested_lets_monadic2_subst</span></a> : <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<a id="x:148" class="idref" href="#x:148"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (3 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 3) <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a>  <span class="comment">(*&nbsp;n.b.&nbsp;substitute&nbsp;<span class="inlinecode">3</span>&nbsp;for&nbsp;<span class="inlinecode"><span class="id" title="var">y</span></span>&nbsp;in&nbsp;<span class="inlinecode"><span class="id" title="var">ret</span></span> <span class="inlinecode">(<span class="id" title="var">y</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span>)</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:148"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2).<br/>
</div>

<div class="doc">
For an arbitrary monad <span class="inlinecode"><span class="id" title="var">M</span></span>, we think of <span class="inlinecode"><span class="id" title="var">ret</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> as a <i>pure</i> computation that
simply yields a value of type <span class="inlinecode"><span class="id" title="var">A</span></span>.  That means we can "substitute" the returned
value directly into the body of the continuation.  That gives us this second
monad law "<span class="inlinecode"><span class="id" title="var">ret</span></span> is the left-identity of <span class="inlinecode"><span class="id" title="var">bind</span></span>".  (Here we use the word
"identity" in the same sense that <span class="inlinecode">1</span> is the identity of multiplication and <span class="inlinecode">0</span>
is the identity of addition; it leaves the result unchanged.) 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="MonadLawsEq.bind_ret_l_law" class="idref" href="#MonadLawsEq.bind_ret_l_law"><span class="id" title="definition">bind_ret_l_law</span></a> {<a id="M:149" class="idref" href="#M:149"><span class="id" title="binder">M</span></a>} `{<a id="H:150" class="idref" href="#H:150"><span class="id" title="binder">Monad</span></a> <a id="H:150" class="idref" href="#H:150"><span class="id" title="binder">M</span></a>} {<a id="A:151" class="idref" href="#A:151"><span class="id" title="binder">A</span></a> <a id="B:152" class="idref" href="#B:152"><span class="id" title="binder">B</span></a>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="a:153" class="idref" href="#a:153"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:151"><span class="id" title="variable">A</span></a>) (<a id="kb:154" class="idref" href="#kb:154"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:151"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:149"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:152"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:155" class="idref" href="#x:155"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#a:153"><span class="id" title="variable">a</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:154"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#x:155"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#kb:154"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#a:153"><span class="id" title="variable">a</span></a>.<br/>
</div>

<div class="doc">
To see what the last monad law means, consider this following example,
again, stated with <span class="inlinecode"><span class="id" title="keyword">let</span></span> notation: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.let_return" class="idref" href="#MonadLawsEq.let_return"><span class="id" title="definition">let_return</span></a> (<a id="m:156" class="idref" href="#m:156"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="x:157" class="idref" href="#x:157"><span class="id" title="binder">x</span></a> := <a class="idref" href="Monads.html#m:156"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#x:157"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
For any specific choice of <span class="inlinecode"><span class="id" title="var">m</span></span>, this trivial <span class="inlinecode"><span class="id" title="keyword">let</span></span> binding is simply
equivalent to <span class="inlinecode"><span class="id" title="var">m</span></span> itself.  Note that this is true only because we are returning
exactly <span class="inlinecode"><span class="id" title="var">x</span></span> and not building some more complex computation using <span class="inlinecode"><span class="id" title="var">x</span></span>. Moreover,
we aren't duplicating <span class="inlinecode"><span class="id" title="var">m</span></span> (which would cause its effects to occur multiple times). 
<div class="paragraph"> </div>

 Rewriting this example using monadic notation we have: 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.let_return_monadic" class="idref" href="#MonadLawsEq.let_return_monadic"><span class="id" title="definition">let_return_monadic</span></a> (<a id="m:158" class="idref" href="#m:158"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) :=<br/>
&nbsp;&nbsp;<a id="x:159" class="idref" href="#x:159"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:158"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#x:159"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
But both of those are just equivalent to <span class="inlinecode"><span class="id" title="var">m</span></span> itself. 
<div class="paragraph"> </div>

 Here again, this trivial use of <span class="inlinecode"><span class="id" title="var">m</span></span> by naming it <span class="inlinecode"><span class="id" title="var">x</span></span> should be exactly the
same as just running the computation <span class="inlinecode"><span class="id" title="var">m</span></span> (the answer, <span class="inlinecode"><span class="id" title="var">x</span></span>, will always be
exactly what <span class="inlinecode"><span class="id" title="var">m</span></span> returns.

<div class="paragraph"> </div>

These observations give us the final monad law, which states that "<span class="inlinecode"><span class="id" title="var">ret</span></span> is the
right-identity of <span class="inlinecode"><span class="id" title="var">bind</span></span>": 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="MonadLawsEq.bind_ret_r_law" class="idref" href="#MonadLawsEq.bind_ret_r_law"><span class="id" title="definition">bind_ret_r_law</span></a> {<a id="M:160" class="idref" href="#M:160"><span class="id" title="binder">M</span></a>} `{<a id="H:161" class="idref" href="#H:161"><span class="id" title="binder">Monad</span></a> <a id="H:161" class="idref" href="#H:161"><span class="id" title="binder">M</span></a>} {<a id="A:162" class="idref" href="#A:162"><span class="id" title="binder">A</span></a>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="m:163" class="idref" href="#m:163"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#M:160"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:162"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:164" class="idref" href="#x:164"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:163"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#x:164"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#m:163"><span class="id" title="variable">m</span></a>.<br/>
</div>

<div class="doc">
<a id="lab156"></a><h3 class="section">Monad Laws</h3>
 Collecting these requirements together, we can define a typeclass that
    captures the requirements that a monad <span class="inlinecode"><span class="id" title="var">M</span></span> satisfies these laws: 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <a id="MonadLawsEq.MonadLaws" class="idref" href="#MonadLawsEq.MonadLaws"><span class="id" title="record">MonadLaws</span></a> {<a id="M:165" class="idref" href="#M:165"><span class="id" title="binder">M</span></a>} `{<a id="H:166" class="idref" href="#H:166"><span class="id" title="binder">Monad</span></a> <a id="H:166" class="idref" href="#H:166"><span class="id" title="binder">M</span></a>} := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="MonadLawsEq.bind_associativity" class="idref" href="#MonadLawsEq.bind_associativity"><span class="id" title="projection">bind_associativity</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="A:168" class="idref" href="#A:168"><span class="id" title="binder">A</span></a> <a id="B:169" class="idref" href="#B:169"><span class="id" title="binder">B</span></a> <a id="C:170" class="idref" href="#C:170"><span class="id" title="binder">C</span></a> (<a id="ma:171" class="idref" href="#ma:171"><span class="id" title="binder">ma</span></a> : <a class="idref" href="Monads.html#M:165"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:168"><span class="id" title="variable">A</span></a>) (<a id="kb:172" class="idref" href="#kb:172"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:168"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:165"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:169"><span class="id" title="variable">B</span></a>) (<a id="kc:173" class="idref" href="#kc:173"><span class="id" title="binder">kc</span></a> : <a class="idref" href="Monads.html#B:169"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:165"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#C:170"><span class="id" title="variable">C</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:175" class="idref" href="#x:175"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:174" class="idref" href="#y:174"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:171"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:172"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:174"><span class="id" title="variable">y</span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:173"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:175"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="y:176" class="idref" href="#y:176"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:171"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a id="x:177" class="idref" href="#x:177"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#kb:172"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:176"><span class="id" title="variable">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:173"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:177"><span class="id" title="variable">x</span></a><br/>
<br/>
&nbsp;&nbsp;; <a id="MonadLawsEq.bind_ret_l" class="idref" href="#MonadLawsEq.bind_ret_l"><span class="id" title="projection">bind_ret_l</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="A:179" class="idref" href="#A:179"><span class="id" title="binder">A</span></a> <a id="B:180" class="idref" href="#B:180"><span class="id" title="binder">B</span></a> (<a id="a:181" class="idref" href="#a:181"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:179"><span class="id" title="variable">A</span></a>) (<a id="kb:182" class="idref" href="#kb:182"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:179"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:165"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:180"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:183" class="idref" href="#x:183"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#a:181"><span class="id" title="variable">a</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:182"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#x:183"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#kb:182"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#a:181"><span class="id" title="variable">a</span></a><br/>
<br/>
&nbsp;&nbsp;; <a id="MonadLawsEq.bind_ret_r" class="idref" href="#MonadLawsEq.bind_ret_r"><span class="id" title="projection">bind_ret_r</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="A:185" class="idref" href="#A:185"><span class="id" title="binder">A</span></a> (<a id="m:186" class="idref" href="#m:186"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#M:165"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:185"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:187" class="idref" href="#x:187"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:186"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#x:187"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#m:186"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
<a id="lab157"></a><h3 class="section">Monadic Reasoning</h3>
 As an example. we can show that a generic version of <span class="inlinecode"><span class="id" title="var">nested_lets_monadic1</span></span>
is equal to <span class="inlinecode"><span class="id" title="var">ret</span></span> <span class="inlinecode">12</span> by explicitly using rewriting with these laws. 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.nested_lets_generic" class="idref" href="#MonadLawsEq.nested_lets_generic"><span class="id" title="definition">nested_lets_generic</span></a> {<a id="M:189" class="idref" href="#M:189"><span class="id" title="binder">M</span></a>} `{<a id="H:190" class="idref" href="#H:190"><span class="id" title="binder">Monad</span></a> <a id="H:190" class="idref" href="#H:190"><span class="id" title="binder">M</span></a>} : <a class="idref" href="Monads.html#M:189"><span class="id" title="variable">M</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<a id="x:192" class="idref" href="#x:192"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:191" class="idref" href="#y:191"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 3 <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#y:191"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="Monads.html#y:191"><span class="id" title="variable">y</span></a>)<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:192"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#ea2ff3d561159081cea6fb2e8113cc<sub>54</sub>"><span class="id" title="notation">×</span></a> 2).<br/>
</div>

<div class="doc">
In the proof below, notice how the state of the monadic computation evolves
as we proceed -- rewriting by this sequence of equivalences "steps" the
computation forward, substituting the returned values through the continuation.
(The connection to evaluation is best observed by stepping through the proof interactively.)

</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="MonadLawsEq.monadic_proof" class="idref" href="#MonadLawsEq.monadic_proof"><span class="id" title="definition">monadic_proof</span></a> {<a id="M:193" class="idref" href="#M:193"><span class="id" title="binder">M</span></a>} `{<a id="H:194" class="idref" href="#H:194"><span class="id" title="binder">Monad</span></a> <a id="H:194" class="idref" href="#H:194"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>1</sub>:196" class="idref" href="#H<sub>1</sub>:196"><span class="id" title="binder">MonadLaws</span></a> <a id="H<sub>1</sub>:196" class="idref" href="#H<sub>1</sub>:196"><span class="id" title="binder">M</span></a>} :<br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#MonadLawsEq.nested_lets_generic"><span class="id" title="definition">nested_lets_generic</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 12.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEq.nested_lets_generic"><span class="id" title="definition">nested_lets_generic</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Monads.html#MonadLawsEq.bind_associativity"><span class="id" title="method">bind_associativity</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Monads.html#MonadLawsEq.bind_ret_l"><span class="id" title="method">bind_ret_l</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Monads.html#MonadLawsEq.bind_ret_l"><span class="id" title="method">bind_ret_l</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
EX1 (monad_laws1)  Use the monad laws and <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ending with <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> to complete the
following proof.
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEq.monad_laws1" class="idref" href="#MonadLawsEq.monad_laws1"><span class="id" title="lemma">monad_laws1</span></a> {<a id="M:197" class="idref" href="#M:197"><span class="id" title="binder">M</span></a>} `{<a id="H:198" class="idref" href="#H:198"><span class="id" title="binder">Monad</span></a> <a id="H:198" class="idref" href="#H:198"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>1</sub>:200" class="idref" href="#H<sub>1</sub>:200"><span class="id" title="binder">MonadLaws</span></a> <a id="H<sub>1</sub>:200" class="idref" href="#H<sub>1</sub>:200"><span class="id" title="binder">M</span></a>} :<br/>
&nbsp;&nbsp;<a id="x:202" class="idref" href="#x:202"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:201" class="idref" href="#y:201"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#y:201"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 3 <span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 0<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a id="z:204" class="idref" href="#z:204"><span class="id" title="binder">z</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="w:203" class="idref" href="#w:203"><span class="id" title="binder">w</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#x:202"><span class="id" title="variable">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <span class="id" title="keyword">if</span> <a class="idref" href="Monads.html#x:202"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Arith.PeanoNat.html#ad2ec4e405f68c46c0a176e3e94ae2e<sub>3</sub>"><span class="id" title="notation">=?</span></a> 0 <span class="id" title="keyword">then</span> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 17 <span class="id" title="keyword">else</span> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 42<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#z:204"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 5)<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> 47.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 EX<sub>2</sub> (monad_laws2)  Use the monad laws and <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ending with <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> to complete the
following proof.
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEq.monad_laws2" class="idref" href="#MonadLawsEq.monad_laws2"><span class="id" title="lemma">monad_laws2</span></a> {<a id="M:205" class="idref" href="#M:205"><span class="id" title="binder">M</span></a>} `{<a id="H:206" class="idref" href="#H:206"><span class="id" title="binder">Monad</span></a> <a id="H:206" class="idref" href="#H:206"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>1</sub>:208" class="idref" href="#H<sub>1</sub>:208"><span class="id" title="binder">MonadLaws</span></a> <a id="H<sub>1</sub>:208" class="idref" href="#H<sub>1</sub>:208"><span class="id" title="binder">M</span></a>} :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="m:209" class="idref" href="#m:209"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#M:205"><span class="id" title="variable">M</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="z:212" class="idref" href="#z:212"><span class="id" title="binder">z</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="x:211" class="idref" href="#x:211"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:210" class="idref" href="#y:210"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:209"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#y:210"><span class="id" title="variable">y</span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:211"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 2)<a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#z:212"><span class="id" title="variable">z</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a id="x:213" class="idref" href="#x:213"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:209"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:213"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 2).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 EX<sub>2</sub> (monad_laws2)  Use the monad laws and <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, ending with <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> to complete the
following proof.
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEq.monad_laws3" class="idref" href="#MonadLawsEq.monad_laws3"><span class="id" title="lemma">monad_laws3</span></a> {<a id="M:214" class="idref" href="#M:214"><span class="id" title="binder">M</span></a>} `{<a id="H:215" class="idref" href="#H:215"><span class="id" title="binder">Monad</span></a> <a id="H:215" class="idref" href="#H:215"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>1</sub>:217" class="idref" href="#H<sub>1</sub>:217"><span class="id" title="binder">MonadLaws</span></a> <a id="H<sub>1</sub>:217" class="idref" href="#H<sub>1</sub>:217"><span class="id" title="binder">M</span></a>} :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="m:218" class="idref" href="#m:218"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#M:214"><span class="id" title="variable">M</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="z:219" class="idref" href="#z:219"><span class="id" title="binder">z</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:218"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a id="y:220" class="idref" href="#y:220"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#z:219"><span class="id" title="variable">z</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#y:220"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a id="x:221" class="idref" href="#x:221"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:218"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> (<a class="idref" href="Monads.html#x:221"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 2).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab158"></a><h3 class="section">Monad Equivalences</h3>

<div class="paragraph"> </div>

 There is one important question that this discussion about well-behaved
monads has swept under the rug, namely: What does it mean for two monadic
computations to be "the same"?  In the monad laws as stated above, we chose
Coq's default <span class="inlinecode">=</span> as "the" equality for computations of monadic type <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.
That choice is appropriate in many situations--it works for <span class="inlinecode"><span class="id" title="var">option</span></span>, for
example--but it is not correct in all cases; the notion of what it means for
two, potentially impure, computations to be "the same" can be quite subtle.

<div class="paragraph"> </div>

We can already start to see the issue if we try to prove the monad laws for
<span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.bind_associativity_state_problematic" class="idref" href="#MonadLawsEqM.bind_associativity_state_problematic"><span class="id" title="lemma">bind_associativity_state_problematic</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="S:222" class="idref" href="#S:222"><span class="id" title="binder">S</span></a> <a id="A:223" class="idref" href="#A:223"><span class="id" title="binder">A</span></a> <a id="B:224" class="idref" href="#B:224"><span class="id" title="binder">B</span></a> <a id="C:225" class="idref" href="#C:225"><span class="id" title="binder">C</span></a> (<a id="ma:226" class="idref" href="#ma:226"><span class="id" title="binder">ma</span></a> : <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:222"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#A:223"><span class="id" title="variable">A</span></a>) (<a id="kb:227" class="idref" href="#kb:227"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:223"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:222"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#B:224"><span class="id" title="variable">B</span></a>) (<a id="kc:228" class="idref" href="#kc:228"><span class="id" title="binder">kc</span></a> : <a class="idref" href="Monads.html#B:224"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:222"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#C:225"><span class="id" title="variable">C</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:230" class="idref" href="#x:230"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:229" class="idref" href="#y:229"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:226"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:227"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:229"><span class="id" title="variable">y</span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:228"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:230"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="y:231" class="idref" href="#y:231"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:226"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a id="x:232" class="idref" href="#x:232"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#kb:227"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:231"><span class="id" title="variable">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:228"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:232"><span class="id" title="variable">x</span></a>.<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a>. <span class="id" title="tactic">simpl</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>
</div>

<div class="doc">
Because <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> is defined as <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, to say what it means for
two stateful computations to be the same means that we have to say what it means
for two <i>functions</i> to be the same.  To proceed from here, we could use
<i>functional extensionality</i>, which is safe to add as an axiom to Coq, but we
can't prove this directly. 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <a id="MonadLawsEqM.AXIOM.functional_extensionality" class="idref" href="#MonadLawsEqM.AXIOM.functional_extensionality"><span class="id" title="axiom">functional_extensionality</span></a> : <span class="id" title="keyword">∀</span> {<a id="A:233" class="idref" href="#A:233"><span class="id" title="binder">A</span></a> <a id="B:234" class="idref" href="#B:234"><span class="id" title="binder">B</span></a>} (<a id="f:235" class="idref" href="#f:235"><span class="id" title="binder">f</span></a> <a id="g:236" class="idref" href="#g:236"><span class="id" title="binder">g</span></a> : <a class="idref" href="Monads.html#A:233"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#B:234"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:237" class="idref" href="#x:237"><span class="id" title="binder">x</span></a>, <a class="idref" href="Monads.html#f:235"><span class="id" title="variable">f</span></a> <a class="idref" href="Monads.html#x:237"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#g:236"><span class="id" title="variable">g</span></a> <a class="idref" href="Monads.html#x:237"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#f:235"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#g:236"><span class="id" title="variable">g</span></a>.<br/>
</div>

<div class="doc">
For <span class="inlinecode"><span class="id" title="var">state</span></span>, it would suffice to adopt functional extensionality to express
its notion of equivalence.  Other monads, however, might require different
notions of "equivalence".  For example, consider a variant of the <span class="inlinecode"><span class="id" title="var">nondet</span></span> monad
where we think of underlying <span class="inlinecode"><span class="id" title="var">list</span></span> as representing a <i>set</i> of values.  In that
case we would want two monadic computations to be considered equal if the lists
representing them contain the <i>same</i> elements, possibly repeated or in different
orders. That notion of equality would allows us to justify more program
optimizations while preserving computation "equivalence".  See the exercises
below where we explore that topic.

<div class="paragraph"> </div>

As related example, we might want to <i>implement</i> the state <span class="inlinecode"><span class="id" title="var">S</span></span> of the <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span>
type using some data structure that itself has a non-trivial equivalence.  We
might implement <span class="inlinecode"><span class="id" title="var">S</span></span> as a finite map of variable to values or as a <span class="inlinecode"><span class="id" title="var">heap</span></span> with a
complicated set of invariants.  In that case, using Coq's <span class="inlinecode">=</span> to compare two
states for equality would not work out, so functional extensionality would again
not be appropriate.

<div class="paragraph"> </div>

To address this issue, it is helpful to state the monad laws parametrically in a
notion of equivalence that can be specified per monad instance.  We therefore
introduce a new typeclass, <span class="inlinecode"><span class="id" title="var">eqM</span></span>, and ask that it be an <span class="inlinecode"><span class="id" title="var">Equivalence</span></span> relation.

<div class="paragraph"> </div>

The price is that we will have to provide such an equivalence for each new monad
that we work with, but, as we shall see later, generalizing this notion of
equivalence even further will give us powerful tools for reasoning about monadic
computations. 
</div>
<div class="code">

<span class="id" title="keyword">Class</span> <a id="MonadLawsEqM.EqM" class="idref" href="#MonadLawsEqM.EqM"><span class="id" title="inductive, record"><span id="MonadLawsEqM.EqM" class="id">EqM</span></span></a> (<a id="M:239" class="idref" href="#M:239"><span class="id" title="binder">M</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a id="MonadLawsEqM.eqM" class="idref" href="#MonadLawsEqM.eqM"><span class="id" title="constructor, projection"><span id="MonadLawsEqM.eqM" class="id">eqM</span></span></a> : <span class="id" title="keyword">∀</span> <a id="A:241" class="idref" href="#A:241"><span class="id" title="binder">A</span></a>, <a class="idref" href="Monads.html#M:239"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:241"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:239"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:241"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>.<br/>
</div>

<div class="doc">
We also require a proof that <span class="inlinecode"><span class="id" title="var">eqM</span></span> is an equivalence relation. 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <a id="MonadLawsEqM.EqMEquivalence" class="idref" href="#MonadLawsEqM.EqMEquivalence"><span class="id" title="inductive, record"><span id="MonadLawsEqM.EqMEquivalence" class="id">EqMEquivalence</span></span></a> (<a id="M:243" class="idref" href="#M:243"><span class="id" title="binder">M</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) `{<a id="H:244" class="idref" href="#H:244"><span class="id" title="binder">EqM</span></a> <a id="H:244" class="idref" href="#H:244"><span class="id" title="binder">M</span></a>} :=<br/>
&nbsp;&nbsp;<a id="MonadLawsEqM.eqM_equiv" class="idref" href="#MonadLawsEqM.eqM_equiv"><span class="id" title="constructor, projection"><span id="MonadLawsEqM.eqM_equiv" class="id">eqM_equiv</span></span></a> : <span class="id" title="keyword">∀</span> <a id="A:246" class="idref" href="#A:246"><span class="id" title="binder">A</span></a>, <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.RelationClasses.html#Equivalence"><span class="id" title="class">Equivalence</span></a> (<a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a> (<span class="id" title="var">A</span> := <a class="idref" href="Monads.html#A:246"><span class="id" title="variable">A</span></a>)).<br/>
</div>

<div class="doc">
Because the notion of monadic equivalence is so prevalant, we introduce
<span class="inlinecode">≈</span> as a succinct, infix version. 
</div>
<div class="code">

<span class="id" title="keyword">Infix</span> <a id="da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>" class="idref" href="#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">&quot;</span></a>≈" := <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">monad_scope</span>.<br/>
</div>

<div class="doc">
Having introduced the appropriate typeclasses for working with monadic
equivalences, we can no recapitulate the monad laws using <span class="inlinecode">≈</span> rather than <span class="inlinecode">=</span>.
For rewriting to work correctly, we also need to ask that the <span class="inlinecode"><span class="id" title="var">bind</span></span> operation
respect <span class="inlinecode">≈</span>, i.e., that it is <span class="inlinecode"><span class="id" title="var">Proper</span></span> with respect to the underlying monad
equivalence.
</div>
<div class="code">

<span class="id" title="keyword">Class</span> <a id="MonadLawsEqM.MonadLaws" class="idref" href="#MonadLawsEqM.MonadLaws"><span class="id" title="record">MonadLaws</span></a> <a id="M:248" class="idref" href="#M:248"><span class="id" title="binder">M</span></a> `{<a id="H:249" class="idref" href="#H:249"><span class="id" title="binder">Monad</span></a> <a id="H:249" class="idref" href="#H:249"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>0</sub>:250" class="idref" href="#H<sub>0</sub>:250"><span class="id" title="binder">EqM</span></a> <a id="H<sub>0</sub>:250" class="idref" href="#H<sub>0</sub>:250"><span class="id" title="binder">M</span></a>} := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="MonadLawsEqM.bind_associativity" class="idref" href="#MonadLawsEqM.bind_associativity"><span class="id" title="projection">bind_associativity</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="A:252" class="idref" href="#A:252"><span class="id" title="binder">A</span></a> <a id="B:253" class="idref" href="#B:253"><span class="id" title="binder">B</span></a> <a id="C:254" class="idref" href="#C:254"><span class="id" title="binder">C</span></a> (<a id="ma:255" class="idref" href="#ma:255"><span class="id" title="binder">ma</span></a> : <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:252"><span class="id" title="variable">A</span></a>) (<a id="kb:256" class="idref" href="#kb:256"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:252"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:253"><span class="id" title="variable">B</span></a>) (<a id="kc:257" class="idref" href="#kc:257"><span class="id" title="binder">kc</span></a> : <a class="idref" href="Monads.html#B:253"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#C:254"><span class="id" title="variable">C</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:259" class="idref" href="#x:259"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">(</span></a><a id="y:258" class="idref" href="#y:258"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:255"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:256"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:258"><span class="id" title="variable">y</span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:257"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:259"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a>                                 <span class="comment">(*&nbsp;&lt;----&nbsp;NEW!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="y:260" class="idref" href="#y:260"><span class="id" title="binder">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#ma:255"><span class="id" title="variable">ma</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a id="x:261" class="idref" href="#x:261"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#kb:256"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#y:260"><span class="id" title="variable">y</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kc:257"><span class="id" title="variable">kc</span></a> <a class="idref" href="Monads.html#x:261"><span class="id" title="variable">x</span></a><br/>
<br/>
&nbsp;&nbsp;; <a id="MonadLawsEqM.bind_ret_l" class="idref" href="#MonadLawsEqM.bind_ret_l"><span class="id" title="projection">bind_ret_l</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="A:263" class="idref" href="#A:263"><span class="id" title="binder">A</span></a> <a id="B:264" class="idref" href="#B:264"><span class="id" title="binder">B</span></a> (<a id="a:265" class="idref" href="#a:265"><span class="id" title="binder">a</span></a> : <a class="idref" href="Monads.html#A:263"><span class="id" title="variable">A</span></a>) (<a id="kb:266" class="idref" href="#kb:266"><span class="id" title="binder">kb</span></a> : <a class="idref" href="Monads.html#A:263"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:264"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:267" class="idref" href="#x:267"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#a:265"><span class="id" title="variable">a</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#kb:266"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#x:267"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#kb:266"><span class="id" title="variable">kb</span></a> <a class="idref" href="Monads.html#a:265"><span class="id" title="variable">a</span></a><br/>
<br/>
&nbsp;&nbsp;; <a id="MonadLawsEqM.bind_ret_r" class="idref" href="#MonadLawsEqM.bind_ret_r"><span class="id" title="projection">bind_ret_r</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="A:269" class="idref" href="#A:269"><span class="id" title="binder">A</span></a> (<a id="m:270" class="idref" href="#m:270"><span class="id" title="binder">m</span></a> : <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:269"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="x:271" class="idref" href="#x:271"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m:270"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#x:271"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#m:270"><span class="id" title="variable">m</span></a><br/>
<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;NEW!&nbsp;*)</span><br/>
&nbsp;&nbsp;; <a id="MonadLawsEqM.Proper_bind" class="idref" href="#MonadLawsEqM.Proper_bind"><span class="id" title="projection">Proper_bind</span></a> : <span class="id" title="keyword">∀</span> {<a id="A:273" class="idref" href="#A:273"><span class="id" title="binder">A</span></a> <a id="B:274" class="idref" href="#B:274"><span class="id" title="binder">B</span></a>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#Proper"><span class="id" title="class">Proper</span></a> (<a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:273"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#A:273"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:274"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:248"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:274"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#8dc5652698a6e16f72dd37bd17d3b973"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#pointwise_relation"><span class="id" title="definition">pointwise_relation</span></a> <span class="id" title="var">_</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#8dc5652698a6e16f72dd37bd17d3b973"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>) <a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a><br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
<a id="lab159"></a><h2 class="section">Properness: a logical relation</h2>

<div class="paragraph"> </div>

 The requirement that <span class="inlinecode"><span class="id" title="var">bind</span></span> be <span class="inlinecode"><span class="id" title="var">Proper</span></span> says that <span class="inlinecode"><span class="id" title="var">bind</span></span> "respects" the
  monad equivalence.  Alternatively, that <span class="inlinecode"><span class="id" title="var">bind</span></span> is in the <i>logical relation</i>
  associated with its type:

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.Proper_bind_def" class="idref" href="#MonadLawsEqM.Proper_bind_def"><span class="id" title="lemma">Proper_bind_def</span></a> : <span class="id" title="keyword">∀</span> <a id="M:276" class="idref" href="#M:276"><span class="id" title="binder">M</span></a> `{<a id="H:277" class="idref" href="#H:277"><span class="id" title="binder">Monad</span></a> <a id="H:277" class="idref" href="#H:277"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>0</sub>:278" class="idref" href="#H<sub>0</sub>:278"><span class="id" title="binder">EqM</span></a> <a id="H<sub>0</sub>:278" class="idref" href="#H<sub>0</sub>:278"><span class="id" title="binder">M</span></a>} `{<a id="H<sub>3</sub>:281" class="idref" href="#H<sub>3</sub>:281"><span class="id" title="binder">MonadLaws</span></a> <a id="H<sub>3</sub>:281" class="idref" href="#H<sub>3</sub>:281"><span class="id" title="binder">M</span></a>} <a id="A:282" class="idref" href="#A:282"><span class="id" title="binder">A</span></a> <a id="B:283" class="idref" href="#B:283"><span class="id" title="binder">B</span></a>,<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a>@<a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#Proper"><span class="id" title="class">Proper</span></a> (<a class="idref" href="Monads.html#M:276"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:282"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#A:282"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:276"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:283"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:276"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:283"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#8dc5652698a6e16f72dd37bd17d3b973"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#pointwise_relation"><span class="id" title="definition">pointwise_relation</span></a> <span class="id" title="var">_</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.Morphisms.html#8dc5652698a6e16f72dd37bd17d3b973"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>) <a class="idref" href="Monads.html#Monad.bind"><span class="id" title="method">bind</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="m<sub>1</sub>:284" class="idref" href="#m<sub>1</sub>:284"><span class="id" title="binder">m<sub>1</sub></span></a> <a id="m<sub>2</sub>:285" class="idref" href="#m<sub>2</sub>:285"><span class="id" title="binder">m<sub>2</sub></span></a> : <a class="idref" href="Monads.html#M:276"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#A:282"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#m<sub>1</sub>:284"><span class="id" title="variable">m<sub>1</sub></span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#m<sub>2</sub>:285"><span class="id" title="variable">m<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="k<sub>1</sub>:286" class="idref" href="#k<sub>1</sub>:286"><span class="id" title="binder">k<sub>1</sub></span></a> <a id="k<sub>2</sub>:287" class="idref" href="#k<sub>2</sub>:287"><span class="id" title="binder">k<sub>2</sub></span></a> : <a class="idref" href="Monads.html#A:282"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#M:276"><span class="id" title="variable">M</span></a> <a class="idref" href="Monads.html#B:283"><span class="id" title="variable">B</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="a<sub>1</sub>:288" class="idref" href="#a<sub>1</sub>:288"><span class="id" title="binder">a<sub>1</sub></span></a> <a id="a<sub>2</sub>:289" class="idref" href="#a<sub>2</sub>:289"><span class="id" title="binder">a<sub>2</sub></span></a> : <a class="idref" href="Monads.html#A:282"><span class="id" title="variable">A</span></a>, <a class="idref" href="Monads.html#a<sub>1</sub>:288"><span class="id" title="variable">a<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#a<sub>2</sub>:289"><span class="id" title="variable">a<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#k<sub>1</sub>:286"><span class="id" title="variable">k<sub>1</sub></span></a> <a class="idref" href="Monads.html#a<sub>1</sub>:288"><span class="id" title="variable">a<sub>1</sub></span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#k<sub>2</sub>:287"><span class="id" title="variable">k<sub>2</sub></span></a> <a class="idref" href="Monads.html#a<sub>2</sub>:289"><span class="id" title="variable">a<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">(</span></a><a id="x:290" class="idref" href="#x:290"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m<sub>1</sub>:284"><span class="id" title="variable">m<sub>1</sub></span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#k<sub>1</sub>:286"><span class="id" title="variable">k<sub>1</sub></span></a> <a class="idref" href="Monads.html#x:290"><span class="id" title="variable">x</span></a><a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">(</span></a><a id="x:291" class="idref" href="#x:291"><span class="id" title="binder">x</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#m<sub>2</sub>:285"><span class="id" title="variable">m<sub>2</sub></span></a><a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#k<sub>2</sub>:287"><span class="id" title="variable">k<sub>2</sub></span></a> <a class="idref" href="Monads.html#x:291"><span class="id" title="variable">x</span></a><a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">)</span></a>.<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>4</sub></span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>6</sub></span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>4</sub></span>; <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>6</sub></span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab160"></a><h3 class="section">Important!</h3>

<div class="paragraph"> </div>

 This generalization from <span class="inlinecode">=</span> to <span class="inlinecode"><span class="id" title="var">eqM</span></span> is the stepping stone
to even more powerful <i>relational reasoning</i> principles that
will naturally extend the <i>computational equivalence</i> to
<i>relational specifications</i>.

</div>

<div class="doc">
<a id="lab161"></a><h3 class="section">Monad Laws for <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span></h3>

<div class="paragraph"> </div>

 With the extra bit of flexibility offered by <span class="inlinecode"><span class="id" title="var">eqM</span></span>, we can now choose an
appropriate notion of equivalence for each monad instance.  For <span class="inlinecode"><span class="id" title="var">state</span></span>, one
simple option is to use <span class="inlinecode">=</span> but then exploit functional extensionality. When
proving the instance of the monad laws. 
<div class="paragraph"> </div>

 First, we define <span class="inlinecode"><span class="id" title="var">eqM</span></span> for <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span>: 
<div class="paragraph"> </div>

 For expediency (and compatibility with SF) we use <span class="inlinecode">=</span> and
  restort to <i>functional_extensionality</i>. 
</div>
<div class="code">
&nbsp;&nbsp;#[<span class="id" title="var">export</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_state" class="idref" href="#MonadLawsEqM.eqM_state"><span class="id" title="instance">eqM_state</span></a> {<a id="S:292" class="idref" href="#S:292"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#MonadLawsEqM.EqM"><span class="id" title="class">EqM</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:292"><span class="id" title="variable">S</span></a>) := <span class="id" title="keyword">fun</span> <a id="A:293" class="idref" href="#A:293"><span class="id" title="binder">A</span></a> ⇒ (@<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <span class="id" title="var">S</span> <a class="idref" href="Monads.html#A:293"><span class="id" title="variable">A</span></a>)).<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;#[<span class="id" title="var">export</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_state_equiv" class="idref" href="#MonadLawsEqM.eqM_state_equiv"><span class="id" title="instance">eqM_state_equiv</span></a> {<a id="S:294" class="idref" href="#S:294"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#MonadLawsEqM.EqMEquivalence"><span class="id" title="class">EqMEquivalence</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:294"><span class="id" title="variable">S</span></a>).<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_state"><span class="id" title="instance">eqM_state</span></a>; <span class="id" title="var">typeclasses</span> <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Next we prove the monad laws: 
</div>
<div class="code">
&nbsp;&nbsp;#[<span class="id" title="var">export</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqm_state_monad_laws" class="idref" href="#MonadLawsEqM.eqm_state_monad_laws"><span class="id" title="instance">eqm_state_monad_laws</span></a> {<a id="S:295" class="idref" href="#S:295"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#MonadLawsEqM.MonadLaws"><span class="id" title="class">MonadLaws</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:295"><span class="id" title="variable">S</span></a>).<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;use&nbsp;functional&nbsp;extensionality(!)&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> σ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ma</span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> σ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> σ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">m</span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">m<sub>1</sub></span> <span class="id" title="var">m<sub>2</sub></span> <span class="id" title="var">EQ</span> <span class="id" title="var">a<sub>1</sub></span> <span class="id" title="var">a<sub>2</sub></span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> σ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">m<sub>2</sub></span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Recall that the <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> monad supports <span class="inlinecode"><span class="id" title="var">get</span></span> and <span class="inlinecode"><span class="id" title="var">put</span></span> as specific
  effectful computations.  Now that we have defined what it means for two state
  monad computations to be equivalent, we can justify equational reasoning
  principles that are specific to <span class="inlinecode"><span class="id" title="var">state</span></span> monad and that take advantage of the
  semantics of stateful operations. 
<div class="paragraph"> </div>

 One example of such an equivalence is given by the following lemma, which
  states that two <span class="inlinecode"><span class="id" title="var">put</span></span> operations in a row is equivalent to doing just the
  second. This lemma explicitly captures the idea that a later store to the
  state overwrites an earlier one.  
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.put_put" class="idref" href="#MonadLawsEqM.put_put"><span class="id" title="lemma">put_put</span></a> {<a id="S:296" class="idref" href="#S:296"><span class="id" title="binder">S</span></a>} : <span class="id" title="keyword">∀</span> (<a id="2c483c4ada72d1a2670a8ac625926e<sub>75</sub>" class="idref" href="#2c483c4ada72d1a2670a8ac625926e<sub>75</sub>"><span class="id" title="binder">σ1</span></a> <a id="33bff261508d683cbd014df93b2fc31b" class="idref" href="#33bff261508d683cbd014df93b2fc31b"><span class="id" title="binder">σ2</span></a> : <a class="idref" href="Monads.html#S:296"><span class="id" title="variable">S</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.put"><span class="id" title="definition">put</span></a> <a class="idref" href="Monads.html#2c483c4ada72d1a2670a8ac625926e<sub>75</sub>"><span class="id" title="variable">σ1</span></a> <a class="idref" href="Monads.html#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.put"><span class="id" title="definition">put</span></a> <a class="idref" href="Monads.html#33bff261508d683cbd014df93b2fc31b"><span class="id" title="variable">σ2</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#Monad.put"><span class="id" title="definition">put</span></a> <a class="idref" href="Monads.html#33bff261508d683cbd014df93b2fc31b"><span class="id" title="variable">σ2</span></a>.<br/>
<div class="togglescript" id="proofcontrol6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')"><span class="show"></span></div>
<div class="proofscript" id="proof6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ1 σ2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Similarly, if we <span class="inlinecode"><span class="id" title="var">put</span></span> a value and then immediately <span class="inlinecode"><span class="id" title="var">get</span></span> the state,
      we could have equally just returned the value, rather than using <span class="inlinecode"><span class="id" title="var">get</span></span>:
  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.put_get" class="idref" href="#MonadLawsEqM.put_get"><span class="id" title="lemma">put_get</span></a> {<a id="S:299" class="idref" href="#S:299"><span class="id" title="binder">S</span></a> <a id="A:300" class="idref" href="#A:300"><span class="id" title="binder">A</span></a>} : <span class="id" title="keyword">∀</span> (<a id="963c31f7a3a14b0d0ab71d1d8a2f2d<sub>75</sub>" class="idref" href="#963c31f7a3a14b0d0ab71d1d8a2f2d<sub>75</sub>"><span class="id" title="binder">σ</span></a> : <a class="idref" href="Monads.html#S:299"><span class="id" title="variable">S</span></a>) (<a id="k:302" class="idref" href="#k:302"><span class="id" title="binder">k</span></a> : <a class="idref" href="Monads.html#S:299"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:299"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#A:300"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#Monad.put"><span class="id" title="definition">put</span></a> <a class="idref" href="Monads.html#963c31f7a3a14b0d0ab71d1d8a2f2d<sub>75</sub>"><span class="id" title="variable">σ</span></a> <a class="idref" href="Monads.html#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#Monad.put"><span class="id" title="definition">put</span></a> <a class="idref" href="Monads.html#963c31f7a3a14b0d0ab71d1d8a2f2d<sub>75</sub>"><span class="id" title="variable">σ</span></a> <a class="idref" href="Monads.html#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="Monads.html#963c31f7a3a14b0d0ab71d1d8a2f2d<sub>75</sub>"><span class="id" title="variable">σ</span></a>.<br/>
<div class="togglescript" id="proofcontrol7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')"><span class="show"></span></div>
<div class="proofscript" id="proof7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ1 <span class="id" title="var">k</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Overwriting the state with the value that it already contains is a no-op. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.get_put" class="idref" href="#MonadLawsEqM.get_put"><span class="id" title="lemma">get_put</span></a> {<a id="S:303" class="idref" href="#S:303"><span class="id" title="binder">S</span></a>} :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="s:304" class="idref" href="#s:304"><span class="id" title="binder">s</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#Monad.put"><span class="id" title="definition">put</span></a> <a class="idref" href="Monads.html#s:304"><span class="id" title="variable">s</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#Monad.ret"><span class="id" title="method">ret</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> : <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:303"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a><a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">)</span></a>.<br/>
<div class="togglescript" id="proofcontrol8" onclick="toggleDisplay('proof8');toggleDisplay('proofcontrol8')"><span class="show"></span></div>
<div class="proofscript" id="proof8" onclick="toggleDisplay('proof8');toggleDisplay('proofcontrol8')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
When we do two <span class="inlinecode"><span class="id" title="var">get</span></span>s without any intervening <span class="inlinecode"><span class="id" title="var">put</span></span>, the value in the state
  does not change. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.get_get" class="idref" href="#MonadLawsEqM.get_get"><span class="id" title="lemma">get_get</span></a> {<a id="S:305" class="idref" href="#S:305"><span class="id" title="binder">S</span></a> <a id="A:306" class="idref" href="#A:306"><span class="id" title="binder">A</span></a>} : <span class="id" title="keyword">∀</span> (<a id="k:307" class="idref" href="#k:307"><span class="id" title="binder">k</span></a> : <a class="idref" href="Monads.html#S:305"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#S:305"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:305"><span class="id" title="variable">S</span></a> <a class="idref" href="Monads.html#A:306"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a id="s<sub>1</sub>:308" class="idref" href="#s<sub>1</sub>:308"><span class="id" title="binder">s<sub>1</sub></span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a id="s<sub>2</sub>:309" class="idref" href="#s<sub>2</sub>:309"><span class="id" title="binder">s<sub>2</sub></span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#k:307"><span class="id" title="variable">k</span></a> <a class="idref" href="Monads.html#s<sub>1</sub>:308"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="Monads.html#s<sub>2</sub>:309"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a id="s<sub>1</sub>:310" class="idref" href="#s<sub>1</sub>:310"><span class="id" title="binder">s<sub>1</sub></span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">&lt;-</span></a> <a class="idref" href="Monads.html#Monad.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Monads.html#3786188b3014de23a57c889c5f8409fc"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#k:307"><span class="id" title="variable">k</span></a> <a class="idref" href="Monads.html#s<sub>1</sub>:310"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="Monads.html#s<sub>1</sub>:310"><span class="id" title="variable">s<sub>1</sub></span></a>.<br/>
<div class="togglescript" id="proofcontrol9" onclick="toggleDisplay('proof9');toggleDisplay('proofcontrol9')"><span class="show"></span></div>
<div class="proofscript" id="proof9" onclick="toggleDisplay('proof9');toggleDisplay('proofcontrol9')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">k</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
These lemmas are the "equational theory" for this simple <span class="inlinecode"><span class="id" title="var">state</span></span> monad.
  We can think of them as defining "algebraic" laws let us replace one sequence
  of stateful operations with another.  Such a theory can be used to prove the
  correctness of program optimizations.

<div class="paragraph"> </div>

  Of course, with this model of state, which has only a single mutable cell, the
  equational theory is fairly simple.  More complex models of mutable state, for
  instance, one modeling a more realistic program memory, would justify
  correspondingly more complex reasoning principles.  Moreover, once other
  computational effects, like concurrency, are involved, such laws might no
  longer be valid.  Each of the laws above is justifiable only if the state
  cannot be modified between the two operations.
  
</div>
<div class="code">
<hr class='doublespaceincode'/>

<br/>
<span class="id" title="keyword">Module</span> <a id="MonadLawsEqM.StateLaws2" class="idref" href="#MonadLawsEqM.StateLaws2"><span class="id" title="module">StateLaws2</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;TODO:&nbsp;Make&nbsp;this&nbsp;into&nbsp;an&nbsp;exercise&nbsp;*)</span><br/>
</div>

<div class="doc">
An alternative definition of <span class="inlinecode"><span class="id" title="var">eqM</span></span> for <span class="inlinecode"><span class="id" title="var">state</span></span>, not taking functional extensionality
as an axiom. 
</div>
<div class="code">

&nbsp;&nbsp;#[<span class="id" title="var">local</span>]<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.StateLaws2.eqM_state" class="idref" href="#MonadLawsEqM.StateLaws2.eqM_state"><span class="id" title="instance">eqM_state</span></a> {<a id="S:311" class="idref" href="#S:311"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#MonadLawsEqM.EqM"><span class="id" title="class">EqM</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:311"><span class="id" title="variable">S</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="A:312" class="idref" href="#A:312"><span class="id" title="binder">A</span></a> (<a id="m<sub>1</sub>:313" class="idref" href="#m<sub>1</sub>:313"><span class="id" title="binder">m<sub>1</sub></span></a> <a id="m<sub>2</sub>:314" class="idref" href="#m<sub>2</sub>:314"><span class="id" title="binder">m<sub>2</sub></span></a> : <a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <span class="id" title="var">S</span> <a class="idref" href="Monads.html#A:312"><span class="id" title="variable">A</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="s<sub>1</sub>:315" class="idref" href="#s<sub>1</sub>:315"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:316" class="idref" href="#s<sub>2</sub>:316"><span class="id" title="binder">s<sub>2</sub></span></a> : <span class="id" title="var">S</span>), <a class="idref" href="Monads.html#s<sub>1</sub>:315"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#s<sub>2</sub>:316"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Monads.html#m<sub>1</sub>:313"><span class="id" title="variable">m<sub>1</sub></span></a> <a class="idref" href="Monads.html#s<sub>1</sub>:315"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Monads.html#m<sub>2</sub>:314"><span class="id" title="variable">m<sub>2</sub></span></a> <a class="idref" href="Monads.html#s<sub>2</sub>:316"><span class="id" title="variable">s<sub>2</sub></span></a>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;#[<span class="id" title="var">local</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.StateLaws2.eqM_state_equiv" class="idref" href="#MonadLawsEqM.StateLaws2.eqM_state_equiv"><span class="id" title="instance">eqM_state_equiv</span></a> {<a id="S:317" class="idref" href="#S:317"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#MonadLawsEqM.EqMEquivalence"><span class="id" title="class">EqMEquivalence</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:317"><span class="id" title="variable">S</span></a>).<br/>
<div class="togglescript" id="proofcontrol10" onclick="toggleDisplay('proof10');toggleDisplay('proofcontrol10')"><span class="show"></span></div>
<div class="proofscript" id="proof10" onclick="toggleDisplay('proof10');toggleDisplay('proofcontrol10')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.StateLaws2.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">eapply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Classes.RelationClasses.html#transitivity"><span class="id" title="definition">transitivity</span></a>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>0</sub></span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Next we prove the monad laws: 
</div>
<div class="code">
&nbsp;&nbsp;#[<span class="id" title="var">local</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.StateLaws2.eqm_state_monad_laws" class="idref" href="#MonadLawsEqM.StateLaws2.eqm_state_monad_laws"><span class="id" title="instance">eqm_state_monad_laws</span></a> {<a id="S:318" class="idref" href="#S:318"><span class="id" title="binder">S</span></a>} : <a class="idref" href="Monads.html#MonadLawsEqM.MonadLaws"><span class="id" title="class">MonadLaws</span></a> (<a class="idref" href="Monads.html#Monad.state"><span class="id" title="definition">state</span></a> <a class="idref" href="Monads.html#S:318"><span class="id" title="variable">S</span></a>).<br/>
<div class="togglescript" id="proofcontrol11" onclick="toggleDisplay('proof11');toggleDisplay('proofcontrol11')"><span class="show"></span></div>
<div class="proofscript" id="proof11" onclick="toggleDisplay('proof11');toggleDisplay('proofcontrol11')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.StateLaws2.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ1 σ <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">ma</span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.StateLaws2.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ1 σ <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.StateLaws2.eqM_state"><span class="id" title="instance">eqM_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> σ1 σ <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">m</span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">m<sub>1</sub></span> <span class="id" title="var">m<sub>2</sub></span> <span class="id" title="var">EQ</span> <span class="id" title="var">a<sub>1</sub></span> <span class="id" title="var">a<sub>2</sub></span> <span class="id" title="var">HP</span> σ1 σ <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">EQ</span> σ σ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">m<sub>2</sub></span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">erewrite</span> <span class="id" title="var">HP</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#MonadLawsEqM.StateLaws2"><span class="id" title="module">StateLaws2</span></a>.<br/>
</div>

<div class="doc">
<a id="lab162"></a><h3 class="section">Monad Laws for <span class="inlinecode"><span class="id" title="var">id</span></span> and <span class="inlinecode"><span class="id" title="var">option</span></span></h3>

<div class="paragraph"> </div>

 We can give a similar instantation of the monad laws for <span class="inlinecode"><span class="id" title="var">id</span></span> and <span class="inlinecode"><span class="id" title="var">option</span></span>,
but in both of those cases we simple use <span class="inlinecode">=</span> as the instance of <span class="inlinecode"><span class="id" title="var">eqM</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Section</span> <a id="MonadLawsEqM.IdLaws" class="idref" href="#MonadLawsEqM.IdLaws"><span class="id" title="section">IdLaws</span></a>.<br/>
</div>

<div class="doc">
First, we define <span class="inlinecode"><span class="id" title="var">eqM</span></span> for <span class="inlinecode"><span class="id" title="var">id</span></span>: 
</div>
<div class="code">

&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_id" class="idref" href="#MonadLawsEqM.eqM_id"><span class="id" title="instance">eqM_id</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.EqM"><span class="id" title="class">EqM</span></a> <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a> := <span class="id" title="keyword">fun</span> <a id="A:319" class="idref" href="#A:319"><span class="id" title="binder">A</span></a> ⇒ (@<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a> <a class="idref" href="Monads.html#A:319"><span class="id" title="variable">A</span></a>)).<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_id_equiv" class="idref" href="#MonadLawsEqM.eqM_id_equiv"><span class="id" title="instance">eqM_id_equiv</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.EqMEquivalence"><span class="id" title="class">EqMEquivalence</span></a> <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a>.<br/>
<div class="togglescript" id="proofcontrol12" onclick="toggleDisplay('proof12');toggleDisplay('proofcontrol12')"><span class="show"></span></div>
<div class="proofscript" id="proof12" onclick="toggleDisplay('proof12');toggleDisplay('proofcontrol12')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_id"><span class="id" title="instance">eqM_id</span></a>; <span class="id" title="var">typeclasses</span> <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Next we prove the monad laws. The only slightly nontrivial case is
<span class="inlinecode"><span class="id" title="var">Proper</span></span>, which needs a bit of rewriting.  
</div>
<div class="code">
&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_id_monad_laws" class="idref" href="#MonadLawsEqM.eqM_id_monad_laws"><span class="id" title="instance">eqM_id_monad_laws</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.MonadLaws"><span class="id" title="class">MonadLaws</span></a> <a class="idref" href="Monads.html#Monad.id"><span class="id" title="definition">id</span></a>.<br/>
<div class="togglescript" id="proofcontrol13" onclick="toggleDisplay('proof13');toggleDisplay('proofcontrol13')"><span class="show"></span></div>
<div class="proofscript" id="proof13" onclick="toggleDisplay('proof13');toggleDisplay('proofcontrol13')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H<sub>0</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#MonadLawsEqM.IdLaws"><span class="id" title="section">IdLaws</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Section</span> <a id="MonadLawsEqM.OptionLaws" class="idref" href="#MonadLawsEqM.OptionLaws"><span class="id" title="section">OptionLaws</span></a>.<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Next, we define <span class="inlinecode"><span class="id" title="var">eqM</span></span> for <span class="inlinecode"><span class="id" title="var">option</span></span> as just <span class="inlinecode">=</span>: 
</div>
<div class="code">

&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_option" class="idref" href="#MonadLawsEqM.eqM_option"><span class="id" title="instance">eqM_option</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.EqM"><span class="id" title="class">EqM</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> := <span class="id" title="keyword">fun</span> <a id="A:320" class="idref" href="#A:320"><span class="id" title="binder">A</span></a> ⇒ (@<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#A:320"><span class="id" title="variable">A</span></a>)).<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_option_equiv" class="idref" href="#MonadLawsEqM.eqM_option_equiv"><span class="id" title="instance">eqM_option_equiv</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.EqMEquivalence"><span class="id" title="class">EqMEquivalence</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a>.<br/>
<div class="togglescript" id="proofcontrol14" onclick="toggleDisplay('proof14');toggleDisplay('proofcontrol14')"><span class="show"></span></div>
<div class="proofscript" id="proof14" onclick="toggleDisplay('proof14');toggleDisplay('proofcontrol14')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_option"><span class="id" title="instance">eqM_option</span></a>; <span class="id" title="var">typeclasses</span> <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Next we prove the monad laws. By destructing the <span class="inlinecode"><span class="id" title="var">option</span></span> value and using
  rewriting for the <span class="inlinecode"><span class="id" title="var">Proper</span></span> case, the laws follow straightforwardly.  
</div>
<div class="code">

&nbsp;&nbsp;#[<span class="id" title="var">export</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_option_monad_laws" class="idref" href="#MonadLawsEqM.eqM_option_monad_laws"><span class="id" title="instance">eqM_option_monad_laws</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.MonadLaws"><span class="id" title="class">MonadLaws</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a>.<br/>
<div class="togglescript" id="proofcontrol15" onclick="toggleDisplay('proof15');toggleDisplay('proofcontrol15')"><span class="show"></span></div>
<div class="proofscript" id="proof15" onclick="toggleDisplay('proof15');toggleDisplay('proofcontrol15')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">ma</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H<sub>0</sub></span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
As with the <span class="inlinecode"><span class="id" title="var">state</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> monad, <span class="inlinecode"><span class="id" title="var">option</span></span> also supports a monad-specific
  equational theory. There is only one interesting law, which states that
  the <span class="inlinecode"><span class="id" title="tactic">fail</span></span> operation terminates the computation: 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a id="MonadLawsEqM.fail_exits" class="idref" href="#MonadLawsEqM.fail_exits"><span class="id" title="lemma">fail_exits</span></a> : <span class="id" title="keyword">∀</span> {<a id="A:321" class="idref" href="#A:321"><span class="id" title="binder">A</span></a> <a id="B:322" class="idref" href="#B:322"><span class="id" title="binder">B</span></a>} (<a id="m:323" class="idref" href="#m:323"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#B:322"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Monads.html#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">(</span></a><a class="idref" href="Monads.html#Monad.:::'fail'"><span class="id" title="notation">fail</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Monads.html#A:321"><span class="id" title="variable">A</span></a><a class="idref" href="Monads.html#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">)</span></a> <a class="idref" href="Monads.html#1da0769dc49b3c22924058237ab38059"><span class="id" title="notation">;;</span></a> <a class="idref" href="Monads.html#m:323"><span class="id" title="variable">m</span></a> <a class="idref" href="Monads.html#da65f4d0dcfa9c79e347b6931f9e3ae<sub>1</sub>"><span class="id" title="notation">≈</span></a> <a class="idref" href="Monads.html#Monad.:::'fail'"><span class="id" title="notation">fail</span></a>.<br/>
<div class="togglescript" id="proofcontrol16" onclick="toggleDisplay('proof16');toggleDisplay('proofcontrol16')"><span class="show"></span></div>
<div class="proofscript" id="proof16" onclick="toggleDisplay('proof16');toggleDisplay('proofcontrol16')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#MonadLawsEqM.OptionLaws"><span class="id" title="section">OptionLaws</span></a>.<br/>
</div>

<div class="doc">
<a id="lab163"></a><h3 class="section">Monad Laws for <span class="inlinecode"><span class="id" title="var">nondet</span></span></h3>

</div>
<div class="code">

<span class="id" title="keyword">Section</span> <a id="MonadLawsEqM.NonDetLaws" class="idref" href="#MonadLawsEqM.NonDetLaws"><span class="id" title="section">NonDetLaws</span></a>.<br/>
</div>

<div class="doc">
As an example of a non-trivial definition of <span class="inlinecode"><span class="id" title="var">eqM</span></span>, let's use this notion
  of equivalence for the list representing a (set) of nondeterministic
  computation. This definition considers the two lists to be equal whenever
  their elements are the same, regardless of order or number of occurrences: 
</div>
<div class="code">

&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_nondet" class="idref" href="#MonadLawsEqM.eqM_nondet"><span class="id" title="instance">eqM_nondet</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.EqM"><span class="id" title="class">EqM</span></a> <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="A:324" class="idref" href="#A:324"><span class="id" title="binder">A</span></a> <a id="m<sub>1</sub>:325" class="idref" href="#m<sub>1</sub>:325"><span class="id" title="binder">m<sub>1</sub></span></a> <a id="m<sub>2</sub>:326" class="idref" href="#m<sub>2</sub>:326"><span class="id" title="binder">m<sub>2</sub></span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:327" class="idref" href="#x:327"><span class="id" title="binder">x</span></a>, <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#In"><span class="id" title="definition">In</span></a> <a class="idref" href="Monads.html#x:327"><span class="id" title="variable">x</span></a> <a class="idref" href="Monads.html#m<sub>1</sub>:325"><span class="id" title="variable">m<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#In"><span class="id" title="definition">In</span></a> <a class="idref" href="Monads.html#x:327"><span class="id" title="variable">x</span></a> <a class="idref" href="Monads.html#m<sub>2</sub>:326"><span class="id" title="variable">m<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:328" class="idref" href="#x:328"><span class="id" title="binder">x</span></a>, <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#In"><span class="id" title="definition">In</span></a> <a class="idref" href="Monads.html#x:328"><span class="id" title="variable">x</span></a> <a class="idref" href="Monads.html#m<sub>2</sub>:326"><span class="id" title="variable">m<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#In"><span class="id" title="definition">In</span></a> <a class="idref" href="Monads.html#x:328"><span class="id" title="variable">x</span></a> <a class="idref" href="Monads.html#m<sub>1</sub>:325"><span class="id" title="variable">m<sub>1</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
It is easy enough to prove that this is an equivalence relation on lists. 
</div>
<div class="code">

&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_nondet_equiv" class="idref" href="#MonadLawsEqM.eqM_nondet_equiv"><span class="id" title="instance">eqM_nondet_equiv</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.EqMEquivalence"><span class="id" title="class">EqMEquivalence</span></a> <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a>.<br/>
<div class="togglescript" id="proofcontrol17" onclick="toggleDisplay('proof17');toggleDisplay('proofcontrol17')"><span class="show"></span></div>
<div class="proofscript" id="proof17" onclick="toggleDisplay('proof17');toggleDisplay('proofcontrol17')">
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="Monads.html#MonadLawsEqM.eqM"><span class="id" title="definition">eqM</span></a>, <a class="idref" href="Monads.html#MonadLawsEqM.eqM_nondet"><span class="id" title="instance">eqM_nondet</span></a>; <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>; <span class="id" title="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Now it remains to see that the monad laws are satisfied up to this notion. 
<div class="paragraph"> </div>

<a id="lab164"></a><h4 class="section">Exercise: 4 stars, standard (eqM_nondet_monad_laws)</h4>
 Complete the following proof that demonstrates that the monad laws hold for <span class="inlinecode"><span class="id" title="var">nondet</span></span>
  with the notion of equivalence defined above.  Hint: you will need to use the List library
  facts about <span class="inlinecode"><span class="id" title="var">In</span></span> and <span class="inlinecode"><span class="id" title="var">flat_map</span></span>.  A key lemma is: <span class="inlinecode"><span class="id" title="var">in_flat_map_Exists</span></span>.
  
</div>
<div class="code">
&nbsp;&nbsp;#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Instance</span> <a id="MonadLawsEqM.eqM_nondet_monad_laws" class="idref" href="#MonadLawsEqM.eqM_nondet_monad_laws"><span class="id" title="instance">eqM_nondet_monad_laws</span></a> : <a class="idref" href="Monads.html#MonadLawsEqM.MonadLaws"><span class="id" title="class">MonadLaws</span></a> <a class="idref" href="Monads.html#Monad.nondet"><span class="id" title="definition">nondet</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Observe that we can also prove that <span class="inlinecode"><span class="id" title="var">nondet</span></span> satisfies the monad laws with
  <span class="inlinecode">=</span> as the notion of equivalence. That means that there is more than one way
  in which a type can be a monad, and the difference depends on what we consider
  to be "the same". 
</div>
<div class="code">
<hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Monads.html#MonadLawsEqM.NonDetLaws"><span class="id" title="section">NonDetLaws</span></a>.<br/>
</div>

<div class="doc">
<a id="lab165"></a><h3 class="section"> </h3>

</div>
<div class="code">
<hr class='doublespaceincode'/>

<br/>
<span class="comment">(*&nbsp;2024-06-13&nbsp;11:26&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>